<table style="border-collapse: collapse; width: 42.3944%;" border="1">
<tbody>
<tr style="height: 140px;">
<td style="width: 100%; height: 140px;">
<h2 style="text-align: left;"><strong>&nbsp;</strong><em>&nbsp;</em><strong><span style="color: #ff0000;">MANISH KUMAR&nbsp;</span></strong></h2>
<h2 style="text-align: left;"><strong>&nbsp;&nbsp;<span style="color: #ff0000;">RA1811029010026</span></strong></h2>
<h2 style="text-align: left;"><strong>&nbsp;&nbsp;<span style="color: #ff0000;">CSE-CN (L2 - section)</span></strong></h2>
</td>
</tr>
</tbody>
</table>
<p><strong><em>&nbsp;WELCOME TO MY WEBSITE!!</em></strong></p>
<h1><span style="text-decoration: underline;">DESIGN AND ANALYSIS OF ALGORITHMS</span></h1>
<p><span style="text-decoration: underline;"><img src="https://www.cdn.geeksforgeeks.org/wp-content/uploads/Competitive-Programming-1.jpg" alt="Top 10 Algorithms and Data Structures for Competitive Programming ..." width="751" height="469" /></span></p>
<p><span style="text-decoration: underline;">TOPICS TO BE COVERED:</span></p>
<p>I Design Techniques;<br />II Searching;<br />III&nbsp;Graph Algorithms;<br />IV&nbsp;Topological Algorithms;<br />V&nbsp;Dynamic Programming</p>
<p>VI&nbsp;NP-Completeness</p>
<h2><span style="text-decoration: underline;"><strong><span style="background-color: #ffff00;">I Design Techniques&nbsp;</span></strong></span></h2>
<p>1.Divide-and-Conquer</p>
<p>2.Dynamic Programming</p>
<p>3.Greedy Algorithm</p>
<h3><span style="color: #ff0000;">1.Divide-and-Conquer:</span></h3>
<p>&nbsp; &nbsp;We use quicksort as an example for an algorithm that follows the divide-and-conquer paradigm. It has the reputation of being the fasted comparison-based sorting algorithm. Indeed it is very fast on the average but can be slow&nbsp;for some input, unless precautions are taken.</p>
<p><span style="text-decoration: underline; background-color: #ff6600;"><em><strong>The algorithm.</strong></em></span>&nbsp;Quicksort follows the general paradigm&nbsp;of divide-and-conquer, which means it divides the unsorted array into two, it recurses on the two pieces, and it&nbsp;finally combines the two sorted pieces to obtain the sorted&nbsp;array. An interesting feature of quicksort is that the divide&nbsp;step separates small from large items. As a consequence,&nbsp;combining the sorted pieces happens automatically without doing anything extra.</p>
<p><br />void QUICKSORT(int ℓ, r)<br />if ℓ &lt; r then m = SPLIT(ℓ, r);<br />QUICKSORT(ℓ, m &minus; 1);<br />QUICKSORT(m + 1, r)<br />endif.</p>
<p><br />We assume the items are stored in A[0..n &minus; 1]. The array&nbsp;is sorted by calling QUICKSORT(0, n &minus; 1).</p>
<p>Splitting. The performance of quicksort depends heavily on the performance of the split operation. The effect of&nbsp;splitting from ℓ to r is:<br />&bull; x = A[ℓ] is moved to its correct location at A[m];<br />&bull; no item in A[ℓ..m &minus; 1] is larger than x;<br />&bull; no item in A[m + 1..r] is smaller than x.</p>
<p>int SPLIT(int ℓ, r)<br />x = A[ℓ]; i = ℓ; j = r + 1;<br />repeat repeat i++ until x &le; A[i];<br />repeat j-- until x &ge; A[j];<br />if i &lt; j then SWAP(i, j) endif<br />until i &ge; j;<br />SWAP(ℓ, j); return j</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://i1.wp.com/gaebster.ch/wp-content/uploads/2018/10/quicksort.png?fit=577%2C410&amp;ssl=1" alt="Quicksort algorithm | Sortingalgorithms | Gabriel Weibel Blog" width="381" height="271" /></p>
<h3><span style="text-decoration: underline; color: #ff0000;"><em><strong>2. Dynamic Programming:</strong></em></span></h3>
<p><span style="color: #000000;">We illustrate dynamic programming using the edit distance problem, which is motivated by questions in genetics. We assume a finite set of characters&nbsp;or letters, &Sigma;, which we refer to as the alphabet, and we<br />consider strings or words formed by concatenating finitely&nbsp;many characters from the alphabet. The edit distance between two words is the minimum number of letter insertions, letter deletions, and letter substitutions required to&nbsp;transform one word to the other. For example, the edit&nbsp;distance between FOOD and MONEY is at most four:<br />FOOD &rarr; MOOD &rarr; MOND &rarr; MONED &rarr; MONEY</span></p>
<p><span style="color: #000000;">PREFIX PROPERTY. If we remove the last column of an&nbsp;optimal edit sequence then the remaining columns&nbsp;represent an optimal edit sequence for the remaining&nbsp;substrings.</span></p>
<p><span style="color: #000000;">The algorithm. If we turned this recurrence relation directly into a divide-and-conquer algorithm, we would have&nbsp;the following recurrence for the running time:&nbsp;</span></p>
<p><span style="color: #000000;"><br />T (m, n) = T (m, n &minus; 1) + T (m &minus; 1, n)<br />+ T (m &minus; 1, n &minus; 1) + 1.</span></p>
<p><span style="color: #000000;"><br />The solution to this recurrence is exponential in m and n,&nbsp;which is clearly not the way to go. Instead, let us build&nbsp;an m + 1 times n + 1 table of possible values of E(i, j).&nbsp;We can start by filling in the base cases, the entries in the&nbsp; 0-th row and column. To fill in any other entry, we need&nbsp;to know the values directly to the left, directly above, and&nbsp;both to the left and above. If we fill the table from top to&nbsp;bottom and from left to right then whenever we reach an&nbsp;entry, the entries it depends on are already available.</span></p>
<p><span style="color: #000000;"><br />int EDITDISTANCE(int m, n)<br />for i = 0 to m do E[i, 0] = i endfor;<br />for j = 1 to n do E[0, j] = j endfor;<br />for i = 1 to m do<br />for j = 1 to n do<br />E[i, j] = min{E[i, j &minus; 1] + 1, E[i &minus; 1, j] + 1,<br />E[i &minus; 1, j &minus; 1] + |A[i] 6= B[j]|}<br />endfor<br />endfor;<br />return E[m, n].</span></p>
<p><span style="color: #000000;"><br />Since there are (m+1)(n+1) entries in the table and each&nbsp;takes a constant time to compute, the total running time is&nbsp;in O(mn).</span></p>
<p><span style="color: #000000;"><em><strong>ALGORITHM and of ALTRUISTIC.</strong> </em>The shaded area highlights the&nbsp;optimal edit sequences, which are paths from the upper left to&nbsp;the lower right corner.<br />A L G O R I T H M<br />A L T R U I S T I C<br />A L G O R I T H M<br />A L T R U I S T I C<br />They are easily recovered by tracing the paths backward,&nbsp;from the end to the beginning. The following algorithm&nbsp;recovers an optimal solution that also minimizes the number of insertions and deletions. We call it with the lengths&nbsp;of the strings as arguments, R(m, n).&nbsp;</span></p>
<p><span style="color: #000000;"><br />void R(int i, j)<br />if i &gt; 0 or j &gt; 0 then<br />switch incoming arrow:<br />case ց: R(i &minus; 1, j &minus; 1); print(A[i], B[j])<br />case &darr;: R(i &minus; 1, j); print(A[i], )<br />case &rarr;: R(i, j &minus; 1); print( , B[j]).<br />endswitch<br />endif.</span></p>
<h3><span style="text-decoration: underline; color: #ff6600;"><em><strong>3.GREEDY ALGORITHM</strong></em></span></h3>
<p>A&nbsp;<strong>greedy algorithm</strong>&nbsp;is a simple, intuitive algorithm that is used in optimization problems. The algorithm makes the optimal choice at each step as it attempts to find the overall optimal way to solve the entire problem. Greedy algorithms are quite successful in some problems, such as&nbsp;<a class="wiki_link" title="Huffman encoding" href="https://brilliant.org/wiki/huffman-encoding/" target="_blank" rel="noopener">Huffman encoding</a>&nbsp;which is used to compress data, or&nbsp;<a class="wiki_link" title="Dijkstra's algorithm" href="https://brilliant.org/wiki/dijkstras-short-path-finder/" target="_blank" rel="noopener">Dijkstra's algorithm</a>, which is used to find the shortest path through a graph.</p>
<p>However, in many problems, a greedy strategy does not produce an optimal solution. For example, in the animation below, the greedy algorithm seeks to find the path with the largest sum. It does this by selecting the largest available number at each step. The greedy algorithm fails to find the largest sum, however, because it makes decisions based only on the information it has at any one step, without regard to the overall problem.</p>
<p><br /><span class="image-caption center"><img style="display: block; margin-left: auto; margin-right: auto;" src="https://d18l82el6cdm1i.cloudfront.net/uploads/xlck8z42EM-greedy-search-path-example.gif" srcset="https://d18l82el6cdm1i.cloudfront.net/uploads/xlck8z42EM-greedy-search-path-example.gif 1x" alt="With a goal of reaching the largest sum, at each step, the greedy algorithm will choose what appears to be the optimal immediate choice, so it will choose 12 instead of 3 at the second step and will not reach the best solution, which contains 99." /></span></p>
<div class="col col-12 col-last wiki-main-column has-sidebar">
<div id="wiki-main" data-controller="app/newsfeed:feed" data-controller-inited="true">
<div id="cmp_wiki_canonical_page_id" class="summary-container">
<div class="summary wiki-content" data-controller="app/wiki:summary,app/zoomable:images" data-cmp-url="/wiki/greedy-algorithm/" data-page-key="wiki_canonical_page" data-cmp-key="wiki_canonical_page" data-controller-inited="true">
<div id="applications" class="anchor skill-heading collapsed" data-controller="app/wiki:expandOrCollapse" data-controller-inited="true"><header class="section-header">
<h2>Applications</h2>
</header></div>
<div id="section-applications" class="section collapsed">
<div class="section-container">
<p>There are many applications of greedy algorithms. Below is a brief explanation of the greedy nature of a famous graph search algorithm, Dijkstra's algorithm.</p>
<h3><strong>Dijkstra's Algorithm</strong></h3>
<p><a href="https://brilliant.org/wiki/dijkstras-short-path-finder/" target="_blank" rel="nofollow noopener">Dijkstra's algorithm</a>&nbsp;is used to find the shortest path between nodes in a graph. The algorithm maintains a set of unvisited nodes and calculates a tentative distance from a given node to another. If the algorithm finds a shorter way to get to a given node, the path is updated to reflect the shorter distance. This problem has satisfactory optimization substructure since if&nbsp;<span class="katex"><span class="katex-mathml">A</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">A</span></span></span></span>&nbsp;is connected to&nbsp;<span class="katex"><span class="katex-mathml">B,</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">B</span><span class="mpunct">,</span></span></span></span>&nbsp;<span class="katex"><span class="katex-mathml">B</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">B</span></span></span></span>&nbsp;is connected to&nbsp;<span class="katex"><span class="katex-mathml">C</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">C</span></span></span></span>, and the path must go through&nbsp;<span class="katex"><span class="katex-mathml">A</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">A</span></span></span></span>&nbsp;and&nbsp;<span class="katex"><span class="katex-mathml">B</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">B</span></span></span></span>&nbsp;to get to the destination&nbsp;<span class="katex"><span class="katex-mathml">C</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">C</span></span></span></span>, then the shortest path from&nbsp;<span class="katex"><span class="katex-mathml">A</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">A</span></span></span></span>&nbsp;to&nbsp;<span class="katex"><span class="katex-mathml">B</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">B</span></span></span></span>&nbsp;and the shortest path from&nbsp;<span class="katex"><span class="katex-mathml">B</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">B</span></span></span></span>&nbsp;to&nbsp;<span class="katex"><span class="katex-mathml">C</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">C</span></span></span></span>&nbsp;must be a part of the shortest path from&nbsp;<span class="katex"><span class="katex-mathml">A</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">A</span></span></span></span>&nbsp;to&nbsp;<span class="katex"><span class="katex-mathml">C</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathdefault">C</span></span></span></span>. So the optimal answers from the subproblems do contribute to the optimal answer for the total problem. This is because the algorithm keeps track of the shortest path possible to any given node.</p>
<p><span class="image-caption center"><img style="max-width: 576px; max-height: 500px; vertical-align: middle; border: 0px; box-sizing: border-box;" src="https://d18l82el6cdm1i.cloudfront.net/uploads/X7rvS7Kbgc-dijkstra_animation.gif" srcset="https://d18l82el6cdm1i.cloudfront.net/uploads/X7rvS7Kbgc-dijkstra_animation.gif 1x" alt="Dijkstra's algorithm to find the shortest path between &lt;strong&gt;a&lt;/strong&gt; and &lt;strong&gt;b&lt;/strong&gt;. It picks the unvisited vertex with the lowest distance, calculates the distance through it to each unvisited neighbor, and updates the neighbor's distance if smaller. Mark visited (set to red) when done with neighbors." /><span class="caption">Dijkstra's algorithm to find the shortest path between&nbsp;<strong>a</strong>&nbsp;and&nbsp;<strong>b</strong>. It picks the unvisited vertex with the lowest distance, calculates the distance through it to each unvisited neighbor, and updates the neighbor's distance if smaller. Mark visited (set to red) when done with neighbors.<sup><a class="citation-link" href="https://brilliant.org/wiki/greedy-algorithm/#citation-4">[4]</a></sup></span></span></p>
<h3><strong>Huffman Coding</strong></h3>
<p><a href="https://brilliant.org/wiki/huffman-encoding/" target="_blank" rel="nofollow noopener">Huffman encoding</a>&nbsp;is another example of an algorithm where a greedy approach is successful. The Huffman algorithm analyzes a message and depending on the frequencies of the characters used in the message, it assigns a variable-length encoding for each symbol. A more commonly used symbol will have a shorter encoding while a rare symbol will have a longer encoding.</p>
<p>The Huffman coding algorithm takes in information about the frequencies or probabilities of a particular symbol occurring. It begins to build the prefix tree from the bottom up, starting with the two least probable symbols in the list. It takes those symbols and forms a subtree containing them, and then removes the individual symbols from the list. The algorithm sums the probabilities of elements in a subtree and adds the subtree and its probability to the list. Next, the algorithm searches the list and selects the two symbols or subtrees with the smallest probabilities. It uses those to make a new subtree, removes the original subtrees/symbols from the list, and then adds the new subtree and its combined probability to the list. This repeats until there is one tree and all elements have been added. At each subtree, the optimal encoding for each symbol is created and together composes the overall optimal encoding.</p>
<p>&nbsp;</p>
<h2><span style="background-color: #ffff00;">&nbsp;II Searching :</span></h2>
<h3><span style="background-color: #ffff00;">4 Binary Search Trees<br />5 Red-black Trees<br />6. Splay Trees</span></h3>
<h3><span style="text-decoration: underline; color: #ff6600;"><em><strong><span style="background-color: #ffffff;">4. BINARY SEARCH TREE:</span></strong></em></span></h3>
<p>For a binary tree to be a binary search tree, the data of all the nodes in the left sub-tree of the root node should be&nbsp;<span id="MathJax-Element-1-Frame" class="MathJax_SVG" style="display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo&gt;&amp;#x2264;&lt;/mo&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">&le;</span></span>&nbsp;the data of the root. The data of all the nodes in the right subtree of the root node should be&nbsp;<span id="MathJax-Element-2-Frame" class="MathJax_SVG" style="display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo&gt;&amp;#x003E;&lt;/mo&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">&gt;</span></span>&nbsp;the data of the root.</p>
<p><strong>Example</strong></p>
<p><img src="https://he-s3.s3.amazonaws.com/media/uploads/fe0eac0.png" alt="enter image description here" width="312" height="234" /></p>
<p>In Fig. 1, consider the root node with data = 10.</p>
<ul>
<li>Data in the left subtree is:&nbsp;<span id="MathJax-Element-3-Frame" class="MathJax_SVG" style="display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">[5,1,6]</span></span></li>
<li>All data elements are&nbsp;<span id="MathJax-Element-4-Frame" class="MathJax_SVG" style="display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo&gt;&amp;#x003C;&lt;/mo&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">&lt;</span></span>&nbsp;<span id="MathJax-Element-5-Frame" class="MathJax_SVG" style="display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">10</span></span></li>
<li>Data in the right subtree is:&nbsp;<span id="MathJax-Element-6-Frame" class="MathJax_SVG" style="display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mn&gt;19&lt;/mn&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mn&gt;17&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">[19,17]</span></span></li>
<li>All data elements are&nbsp;<span id="MathJax-Element-7-Frame" class="MathJax_SVG" style="display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo&gt;&amp;#x003E;&lt;/mo&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">&gt;</span></span>&nbsp;<span id="MathJax-Element-8-Frame" class="MathJax_SVG" style="display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;10&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">10</span></span></li>
</ul>
<p>Also, considering the root node with&nbsp;<span id="MathJax-Element-9-Frame" class="MathJax_SVG" style="display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">data=5</span></span>, its children also satisfy the specified ordering. Similarly, the root node with&nbsp;<span id="MathJax-Element-10-Frame" class="MathJax_SVG" style="display: inline-block; font-style: normal; font-weight: normal; line-height: normal; font-size: 14px; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; overflow-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;19&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">data=19</span></span>&nbsp;also satisfies this ordering. When recursive, all subtrees satisfy the left and right subtree ordering.</p>
<p>The tree is known as a Binary Search Tree or BST.</p>
<p><strong>Traversing the tree</strong></p>
<p>There are mainly&nbsp;<em>three</em>&nbsp;types of tree traversals.</p>
<p><strong><em>Pre-order traversal</em></strong></p>
<p>In this traversal technique the traversal order is root-left-right i.e.</p>
<ul>
<li>Process data of root node</li>
<li>First, traverse left subtree completely</li>
<li>Then, traverse right subtree</li>
</ul>
<pre class="prettyprint prettyprinted"><code>    <span class="kwd">void</span><span class="pln"> perorder</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node</span><span class="pun">*</span><span class="pln">root</span><span class="pun">)</span>
    <span class="pun">{</span>
        <span class="kwd">if</span><span class="pun">(</span><span class="pln">root</span><span class="pun">)</span>
        <span class="pun">{</span><span class="pln">
            printf</span><span class="pun">(</span><span class="str">"%d "</span><span class="pun">,</span><span class="pln">root</span><span class="pun">-&gt;</span><span class="pln">data</span><span class="pun">);</span>    <span class="com">//Printf root-&gt;data</span><span class="pln">
            preorder</span><span class="pun">(</span><span class="pln">root</span><span class="pun">-&gt;</span><span class="pln">left</span><span class="pun">);</span>    <span class="com">//Go to left subtree</span><span class="pln">
            preorder</span><span class="pun">(</span><span class="pln">root</span><span class="pun">-&gt;</span><span class="pln">right</span><span class="pun">);</span>     <span class="com">//Go to right subtree</span>
        <span class="pun">}</span>
    <span class="pun">}</span></code></pre>
<p><strong>Post-order traversal</strong></p>
<p>In this traversal technique the traversal order is left-right-root.</p>
<ul>
<li>Process data of left subtree</li>
<li>First, traverse right subtree</li>
<li>Then, traverse root node</li>
</ul>
<pre class="prettyprint prettyprinted"><code>    <span class="kwd">void</span><span class="pln"> postorder</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node</span><span class="pun">*</span><span class="pln">root</span><span class="pun">)</span>
    <span class="pun">{</span>
        <span class="kwd">if</span><span class="pun">(</span><span class="pln">root</span><span class="pun">)</span>
        <span class="pun">{</span><span class="pln">
            postorder</span><span class="pun">(</span><span class="pln">root</span><span class="pun">-&gt;</span><span class="pln">left</span><span class="pun">);</span>    <span class="com">//Go to left sub tree</span><span class="pln">
            postorder</span><span class="pun">(</span><span class="pln">root</span><span class="pun">-&gt;</span><span class="pln">right</span><span class="pun">);</span>     <span class="com">//Go to right sub tree</span><span class="pln">
            printf</span><span class="pun">(</span><span class="str">"%d "</span><span class="pun">,</span><span class="pln">root</span><span class="pun">-&gt;</span><span class="pln">data</span><span class="pun">);</span>    <span class="com">//Printf root-&gt;data</span>
        <span class="pun">}</span>
    <span class="pun">}</span></code></pre>
<p><strong>In-order traversal</strong></p>
<p>In in-order traversal, do the following:</p>
<ul>
<li>First process left subtree (before processing root node)</li>
<li>Then, process current root node</li>
<li>Process right subtree</li>
</ul>
<h2 class="prettyprint prettyprinted"><code>    <span class="kwd">void</span><span class="pln"> inorder</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node</span><span class="pun">*</span><span class="pln">root</span><span class="pun">)</span>
    <span class="pun">{</span>
        <span class="kwd">if</span><span class="pun">(</span><span class="pln">root</span><span class="pun">)</span>
        <span class="pun">{</span><span class="pln">
            inorder</span><span class="pun">(</span><span class="pln">root</span><span class="pun">-&gt;</span><span class="pln">left</span><span class="pun">);</span>    <span class="com">//Go to left subtree</span><span class="pln">
            printf</span><span class="pun">(</span><span class="str">"%d "</span><span class="pun">,</span><span class="pln">root</span><span class="pun">-&gt;</span><span class="pln">data</span><span class="pun">);</span>    <span class="com">//Printf root-&gt;data</span><span class="pln">
            inorder</span><span class="pun">(</span><span class="pln">root</span><span class="pun">-&gt;</span><span class="pln">right</span><span class="pun">);</span>     <span class="com">//Go to right subtree</span>
        <span class="pun">}</span>
    <span class="pun">}<br /><br /><br /><span style="text-decoration: underline;"><span style="color: #ff0000; text-decoration: underline;">5. RED-BLACK TREES</span></span><br /></span></code></h2>
<h4>Red-black Trees</h4>
<p>Red-black trees are an evolution of binary search trees that aim to keep the tree balanced without affecting the complexity of the primitive operations. This is done by coloring each node in the tree with either red or black and preserving a set of properties that guarantee that the deepest path in the tree is not longer than twice the shortest one.</p>
<p>A red-black tree is a binary search tree with the following properties:</p>
<ol>
<li>
<p>Every node is colored with either red or black.</p>
</li>
<li>
<p>All leaf (nil) nodes are colored with black; if a node&rsquo;s child is missing then we will assume that it has a nil child in that place and this nil child is always colored black.</p>
</li>
<li>
<p>Both children of a red node must be black nodes.</p>
</li>
<li>
<p>Every path from a node n to a descendent leaf has the same number of black nodes (not counting node n). We call this number the black height of n, which is denoted by bh(n).</p>
</li>
</ol>
<p>Figure 5 shows an example of a red-black tree.</p>
<center><br /><img src="http://community.topcoder.com/i/education/rbtrees5.jpg" /></center>
<p>Using these properties, we can show in two steps that a red-black tree which contains n nodes has a height of O(log n), thus all primitive operations on the tree will be of O(log n) since their order is a function of tree height.</p>
<ol>
<li>
<p>First, notice that for a red-black tree with height h, bh(root) is at least h/2 by property 3 above (as each red node strictly requires black children).</p>
</li>
<li>
<p>The next step is to use the following lemma:</p>
<ul>
<li>
<p>Lemma: A subtree rooted at node v has at least 2^bh(v) &ndash; 1 internal nodes</p>
</li>
<li>
<p>Proof by induction: The basis is when h(v) = 0, which means that v is a leaf node and therefore bh(v) = 0 and the subtree rooted at node v has 2^bh(v)-1 = 2^0-1 = 1-1 = 0 nodes.</p>
</li>
<li>
<p>Inductive hypothesis: if node v1 with height x has 2^bh(v1)-1 internal nodes then node v2 with height x+1 has 2^bh(v2)-1</p>
</li>
</ul>
</li>
</ol>
<p>For any non-leaf node v (height &gt; 0) we can see that the black height of any of its two children is at least equal to bh(v)-1 &mdash; if the child is black, that is, otherwise it is equal to bh(v) . By applying the hypothesis above we conclude that each child has at least 2^[bh(v)-1]-1 internal nodes, accordingly node v has at least<br />2^[bh(v)-1]-1 + 2^[bh(v)-1]-1 + 1 = 2^bh(v)-1<br />internal nodes, which ends the proof.</p>
<p>By applying the lemma to the root node (with bh of at least h/2, as shown above) we get<br />n &gt;= 2^(h/2) &ndash; 1<br />where n is the number of internal nodes of a red-black tree (the subtree rooted at the root). Playing with the equation a little bit we get h &lt;= 2 log (n+1), which guarantees the logarithmic bound of red-black trees.</p>
<h4>Rotations</h4>
<p>How does inserting or deleting nodes affect a red-black tree? To ensure that its color scheme and properties don&rsquo;t get thrown off, red-black trees employ a key operation known as rotation. Rotation is a binary operation, between a parent node and one of its children, that swaps nodes and modifys their pointers while preserving the inorder traversal of the tree (so that elements are still sorted).</p>
<p>There are two types of rotations: left rotation and right rotation. Left rotation swaps the parent node with its right child, while right rotation swaps the parent node with its left child. Here are the steps involved in for left rotation (for right rotations just change &ldquo;left&rdquo; to &ldquo;right&rdquo; below):</p>
<ul>
<li>
<p>Assume node x is the parent and node y is a non-leaf right child.</p>
</li>
<li>
<p>Let y be the parent and x be its left child.</p>
</li>
<li>
<p>Let y&rsquo;s left child be x&rsquo;s right child.</p>
</li>
</ul>
<center><br /><img src="http://community.topcoder.com/i/education/rbtrees6.jpg" /></center>
<p>Operations on red-black tree (insertion, deletion and retrieval)</p>
<p>Red-black tree operations are a modified version of BST operations, with the modifications aiming to preserve the properties of red-black trees while keeping the operations complexity a function of tree height.</p>
<h3>Red-black tree insertion:</h3>
<p>Inserting a node in a red-black tree is a two step process:</p>
<ol>
<li>
<p>A BST insertion, which takes O(log n) as shown before.</p>
</li>
<li>
<p>Fixing any violations to red-black tree properties that may occur after applying step 1. This step is O(log n) also, as we start by fixing the newly inserted node, continuing up along the path to the root node and fixing nodes along that path. Fixing a node is done in constant time and involves re-coloring some nodes and doing rotations.</p>
</li>
</ol>
<p>Accordingly the total running time of the insertion process is O(log n). Figure 7 shows the red-black tree in figure 5 before and after insertion of a node with value 4. You can see how the swap operations modified the tree structure to keep it balanced.</p>
<center><br /><img src="http://community.topcoder.com/i/education/rbtrees7.jpg" /></center>
<h3>Red-black tree deletion:</h3>
<p>The same concept behind red-black tree insertions applies here. Removing a node from a red-black tree makes use of the BST deletion procedure and then restores the red-black tree properties in O(log n). The total running time for the deletion process takes O(log n) time, then, which meets the complexity requirements for the primitive operations.</p>
<h3>Red-black tree retrieval:</h3>
<p>Retrieving a node from a red-black tree doesn&rsquo;t require more than the use of the BST procedure, which takes O(log n) time.</p>
<h2><span style="color: #ff0000;">6.SPLAY TREES</span></h2>
<p>Splay trees are self-adjusting binary search trees i.e., they adjust their nodes after accessing them. So, after searching, inserting or deleting a node, the tree will get adjusted.</p>
<p>Splay trees put the most recently accessed items near the root based on the principle of locality; 90-10 "rule" which states that 10% of the data is accessed 90% of the time, other 90% of data is only accessed only 10% of the time.</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://www.codesdope.com/staticroot/images/ds/splay1.png" alt="rule for splay tree" width="247" height="209" /></p>
<p>Thus, there is a 90% chance that the elements near the root of a splay tree are going to be accessed in an operation.</p>
<p>Let's learn how these trees adjust nodes on accessing them.</p>
<p>&nbsp;</p>
<h2>Splaying</h2>
<hr />
<p>"Splaying" is a process in which a node is transferred to the root by performing suitable rotations. In a splay tree, whenever we access any node, it is splayed to the root. It will be clear</p>
<p>with the examples given in this chapter.</p>
<p>There are few terminologies used in this process. Let's learn about those.</p>
<h3>Zig-Zig and Zig-Zag</h3>
<hr />
<p>When the parent and the grandparent of a node are in the same direction, it is&nbsp;<strong>zig-zig</strong>.</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://www.codesdope.com/staticroot/images/ds/splay2.png" alt="zig-zig" width="193" height="215" /></p>
<p>When the parent and the grandparent of a node are in different directions, it is&nbsp;<strong>zig-zag</strong>.</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://www.codesdope.com/staticroot/images/ds/splay3.png" alt="zig-zag" width="208" height="292" /></p>
<p>Whenever we access a node, we shift it to the root by using suitable rotations. Let's take the following example.</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://www.codesdope.com/staticroot/images/ds/splay4.png" alt="splaying to root" width="453" height="212" /></p>
<p>Here, we have performed a single right rotation and a&nbsp;<strong>single rotation</strong>&nbsp;is termed as "zig".</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://www.codesdope.com/staticroot/images/ds/splay5.png" alt="single rotation in splay" width="278" height="170" /></p>
<p>"zig-zag" consists of two rotations of the opposite direction. Take a look at the following example.</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://www.codesdope.com/staticroot/images/ds/splay6.png" alt="zig-zag in splaying" width="481" height="232" /></p>
<p>Let's take a look at the following example in which we have accessed the node&nbsp;<em>R</em>.</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://www.codesdope.com/staticroot/images/ds/splay7.png" alt="splaying a node" width="563" height="254" /></p>
<p>So, we have performed two single rotations of the same direction to bring the node at the root. This is "zig-zig".</p>
<p>Let's take a look at some examples.</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://www.codesdope.com/staticroot/images/ds/splay8.png" alt="example of splaying" width="550" height="259" /></p>
<div class="well imp_well">&nbsp;
<h2>Searching in a Splay Tree</h2>
<hr />
<p>Searching is just the same as a normal binary search tree, we just splay the node which was searched to the root</p>
<pre>SEARCH(T, n, x)
    if x == n.data
        SPLAY(T, n)
        return n
    else if x &lt; n.data
        return search(T, n.left, x);
    else if x &gt; n.data
        return search(T, n.right, x);
    else
        return NULL<br /><br /></pre>
<h2>Insertion in a Splay Tree</h2>
<hr />
<p>We normally insert a node in a splay tree and splay it to the root.</p>
<p><img style="float: left;" src="https://www.codesdope.com/staticroot/images/ds/splay11.png" alt="insertion in splay tree" width="197" height="316" /></p>
<p>INSERT(T, n)<br /> temp = T.root<br /> y = NULL<br /> while temp != NULL<br /> y = temp<br /> if n.data &lt; temp.data<br /> temp = temp.left<br /> else<br /> temp = temp.right<br /> n.parent = y<br /> if y==NULL<br /> T.root = n<br /> else if n.data &lt; y.data<br /> y.left = n<br /> else<br /> y.right = n</p>
<p>SPLAY(T, n)</p>
<p>&nbsp;</p>
<h1><span style="background-color: #ffff00;"><em><strong>III&nbsp;Graph Algorithms;</strong></em></span></h1>
<p><span style="background-color: #ffff00;"><em><strong>7. Graph Search&nbsp;<br />8. Shortest Paths&nbsp;<br />9. Minimum Spanning Trees&nbsp;<br /></strong></em></span></p>
<h2><span style="text-decoration: underline;"><span style="background-color: #ffffff; color: #ff9900; text-decoration: underline;">7.GRAPH SEARCH:</span></span></h2>
<p><span style="background-color: #ffffff;">We can think of graphs as generalizations of trees: they&nbsp;consist of nodes and edges connecting nodes. The main&nbsp;difference is that graphs do not in general represent hierarchical&nbsp;organizations.<br />Types of graphs. Different applications require different&nbsp;types of graphs. The most basic type is the simple&nbsp;undirected graph that consists of a set V of vertices and a&nbsp;set E of edges. Each edge is an unordered pair (a set) of&nbsp;two vertices. We always assume V is finite.</span></p>
<p><span style="background-color: #ffffff;">&nbsp;<br />&nbsp;Similarly, because each edge is a set (of two vertices), it cannot connect to the same vertex twice.&nbsp;Vertices u and v are adjacent if {u, v} &isin; E. In this case u&nbsp;and v are called neighbors. Other types of graphs are<br />directed: E &sube; V &times; V .&nbsp;weighted: has a weighting function w : E &rarr; R.&nbsp;labeled: has a labeling function ℓ : V &rarr; Z.&nbsp;non-simple: there are loops and multi-edges.&nbsp;A loop is like an edge, except that it connects to the same&nbsp;vertex twice. A multi-edge consists of two or more edges&nbsp;connecting the same two vertices.</span></p>
<h3><span style="background-color: #ffffff; color: #ff9900;">-&gt; Depth first search (DFS)</span></h3>
<p>Depth first search (DFS) algorithm starts with the initial node of the graph G, and then goes to deeper and deeper until we find the goal node or the node which has no children. The algorithm, then backtracks from the dead end towards the most recent node that is yet to be completely unexplored.</p>
<p>The data structure which is being used in DFS is stack. The process is similar to BFS algorithm. In DFS, the edges that leads to an unvisited node are called discovery edges while the edges that leads to an already visited node are called block edges.</p>
<h2 class="h2">Algorithm</h2>
<ul class="points">
<li><strong>Step 1:</strong>&nbsp;SET STATUS = 1 (ready state) for each node in G</li>
<li><strong>Step 2:</strong>&nbsp;Push the starting node A on the stack and set its STATUS = 2 (waiting state)</li>
<li><strong>Step 3:</strong>&nbsp;Repeat Steps 4 and 5 until STACK is empty</li>
<li><strong>Step 4:</strong>&nbsp;Pop the top node N. Process it and set its STATUS = 3 (processed state)</li>
<li><strong>Step 5:</strong>&nbsp;Push on the stack all the neighbours of N that are in the ready state (whose STATUS = 1) and set their<br />STATUS = 2 (waiting state)<br />[END OF LOOP]</li>
<li><strong>Step 6:</strong>&nbsp;EXIT</li>
</ul>
<p>Let's see how the Depth First Search algorithm works with an example. We use an undirected graph with 5 vertices.</p>
<figure><img style="display: block; margin-left: auto; margin-right: auto;" src="https://cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-0.jpg" alt="We start from vertex 0, the DFS algorithm starts by putting it in the Visited list and putting all its adjacent vertices in the stack." /></figure>
<p>We start from vertex 0, the DFS algorithm starts by putting it in the Visited list and putting all its adjacent vertices in the stack.</p>
<figure><img style="display: block; margin-left: auto; margin-right: auto;" src="https://cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-1.jpg" alt="Next, we visit the element at the top of stack i.e. 1 and go to its adjacent nodes. Since 0 has already been visited, we visit 2 instead." /></figure>
<p>Next, we visit the element at the top of stack i.e. 1 and go to its adjacent nodes. Since 0 has already been visited, we visit 2 instead.</p>
<figure><img style="display: block; margin-left: auto; margin-right: auto;" src="https://cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-2.jpg" alt="Next, we visit the element at the top of stack i.e. 1 and go to its adjacent nodes. Since 0 has already been visited, we visit 2 instead." /></figure>
<p>Vertex 2 has an unvisited adjacent vertex in 4, so we add that to the top of the stack and visit it.</p>
<figure><img style="display: block; margin-left: auto; margin-right: auto;" src="https://cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-3.jpg" alt="Vertex 2 has an unvisited adjacent vertex in 4, so we add that to the top of the stack and visit it." /></figure>
<figure><img style="display: block; margin-left: auto; margin-right: auto;" src="https://cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-4.jpg" alt="Vertex 2 has an unvisited adjacent vertex in 4, so we add that to the top of the stack and visit it." /></figure>
<p>After we visit the last element 3, it doesn't have any unvisited adjacent nodes, so we have completed the Depth First Traversal of the graph.</p>
<figure><img style="display: block; margin-left: auto; margin-right: auto;" src="https://cdn.programiz.com/sites/tutorial2program/files/graph-dfs-step-5.jpg" alt="After we visit the last element 3, it doesn't have any unvisited adjacent nodes, so we have completed the Depth First Traversal of the graph." /></figure>
<h2><span style="color: #ff9900;"><strong><span style="text-decoration: underline;">8. SHORTEST PATHS:</span></strong></span></h2>
<p>One of the most common operations in graphs is finding&nbsp;shortest paths between vertices. This section discusses&nbsp;three algorithms for this problem: breadth-first search&nbsp;for unweighted graphs, Dijkstra&rsquo;s algorithm for weighted&nbsp;graphs, and the Floyd-Warshall algorithm for computing&nbsp;distances between all pairs of vertices.</p>
<h2 class="h2">Breadth First Search (BFS) Algorithm</h2>
<p>Breadth first search is a graph traversal algorithm that starts traversing the graph from root node and explores all the neighbouring nodes. Then, it selects the nearest node and explore all the unexplored nodes. The algorithm follows the same process for each of the nearest node until it finds the goal.</p>
<ul>
<li>The algorithm of breadth first search is given below. The algorithm starts with examining the node A and all of its neighbours. In the next step, the neighbours of the nearest node of A are explored and process continues in the further steps. The algorithm explores all neighbours of all the nodes and ensures that each node is visited exactly once and no node is visited twice.</li>
</ul>
<h2 class="h2">Algorithm</h2>
<ul class="points">
<li><strong>Step 1:</strong>&nbsp;SET STATUS = 1 (ready state)&nbsp;for each node in G</li>
<li><strong>Step 2:</strong>&nbsp;Enqueue the starting node A&nbsp;and set its STATUS = 2&nbsp;(waiting state)</li>
<li><strong>Step 3:</strong>&nbsp;Repeat Steps 4 and 5 until&nbsp;QUEUE is empty</li>
<li><strong>Step 4:</strong>&nbsp;Dequeue a node N. Process it&nbsp;and set its STATUS = 3&nbsp;(processed state).</li>
<li><strong>Step 5:</strong>&nbsp;Enqueue all the neighbours of&nbsp;N that are in the ready state&nbsp;(whose STATUS = 1) and set&nbsp;their STATUS = 2&nbsp;(waiting state)<br />[END OF LOOP]</li>
<li><strong>Step 6:</strong>&nbsp;EXIT</li>
</ul>
<p>Consider the graph G shown in the following image, calculate the minimum path p from node A to node E. Given that each edge has a length of 1.</p>
<p><br /><img style="display: block; margin-left: auto; margin-right: auto;" src="https://static.javatpoint.com/ds/images/breadth-first-search-algorithm-example.png" alt="Breadth First Search Algorithm" /></p>
<p>Minimum Path P can be found by applying breadth first search algorithm that will begin at node A and will end at E. the algorithm uses two queues, namely&nbsp;<strong>QUEUE1</strong>&nbsp;and&nbsp;<strong>QUEUE2</strong>.&nbsp;<strong>QUEUE1</strong>&nbsp;holds all the nodes that are to be processed while&nbsp;<strong>QUEUE2</strong>&nbsp;holds all the nodes that are processed and deleted from&nbsp;<strong>QUEUE1</strong>.</p>
<p><strong>Lets start examining the graph from Node A.</strong></p>
<p>1. Add A to QUEUE1 and NULL to QUEUE2.&nbsp;</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt">QUEUE1&nbsp;=&nbsp;{A}&nbsp;&nbsp;</li>
<li class="">QUEUE2&nbsp;=&nbsp;{NULL}&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>2. Delete the Node A from QUEUE1 and insert all its neighbours. Insert Node A into QUEUE2&nbsp;</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt">QUEUE1&nbsp;=&nbsp;{B,&nbsp;D}&nbsp;&nbsp;</li>
<li class="">QUEUE2&nbsp;=&nbsp;{A}&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>3. Delete the node B from QUEUE1 and insert all its neighbours. Insert node B into QUEUE2.&nbsp;</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt">QUEUE1&nbsp;=&nbsp;{D,&nbsp;C,&nbsp;F}&nbsp;&nbsp;&nbsp;</li>
<li class="">QUEUE2&nbsp;=&nbsp;{A,&nbsp;B}&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>4. Delete the node D from QUEUE1 and insert all its neighbours. Since F is the only neighbour of it which has been inserted, we will not insert it again. Insert node D into QUEUE2.&nbsp;</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt">QUEUE1&nbsp;=&nbsp;{C,&nbsp;F}&nbsp;&nbsp;</li>
<li class="">QUEUE2&nbsp;=&nbsp;{&nbsp;A,&nbsp;B,&nbsp;D}&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>5. Delete the node C from QUEUE1 and insert all its neighbours. Add node C to QUEUE2.&nbsp;</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt">QUEUE1&nbsp;=&nbsp;{F,&nbsp;E,&nbsp;G}&nbsp;&nbsp;</li>
<li class="">QUEUE2&nbsp;=&nbsp;{A,&nbsp;B,&nbsp;D,&nbsp;C}&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>6. Remove F from QUEUE1 and add all its neighbours. Since all of its neighbours has already been added, we will not add them again. Add node F to QUEUE2.&nbsp;</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt">QUEUE1&nbsp;=&nbsp;{E,&nbsp;G}&nbsp;&nbsp;</li>
<li class="">QUEUE2&nbsp;=&nbsp;{A,&nbsp;B,&nbsp;D,&nbsp;C,&nbsp;F}&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>7. Remove E from QUEUE1, all of E's neighbours has already been added to QUEUE1 therefore we will not add them again. All the nodes are visited and the target node i.e. E is encountered into QUEUE2.&nbsp;</p>
<div class="codeblock">
<div class="dp-highlighter">
<ol class="dp-j" start="1">
<li class="alt">QUEUE1&nbsp;=&nbsp;{G}&nbsp;&nbsp;</li>
<li class="">QUEUE2&nbsp;=&nbsp;{A,&nbsp;B,&nbsp;D,&nbsp;C,&nbsp;F,&nbsp;&nbsp;E}&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p>Now, backtrack from E to A, using the nodes available in QUEUE2.</p>
<p>The minimum path will be&nbsp;<strong>A &rarr; B &rarr; C &rarr; E</strong>.</p>
<p>&nbsp;</p>
<h1 class="h1">Dijkstra's Algorithm</h1>
<p>It is a greedy algorithm that solves the single-source shortest path problem for a directed graph G = (V, E) with nonnegative edge weights, i.e., w (u, v) &ge; 0 for each edge (u, v) &isin; E.</p>
<p>Dijkstra's Algorithm maintains a set S of vertices whose final shortest - path weights from the source s have already been determined. That's for all vertices v &isin; S; we have d [v] = &delta; (s, v). The algorithm repeatedly selects the vertex u &isin; V - S with the minimum shortest - path estimate, insert u into S and relaxes all edges leaving u.</p>
<p>Because it always chooses the "lightest" or "closest" vertex in V - S to insert into set S, it is called as the&nbsp;<strong>greedy strategy</strong>.</p>
<div class="codeblock">
<pre><strong>Dijkstra's Algorithm (G, w, s)</strong>
 1. INITIALIZE - SINGLE - SOURCE (G, s)
 2. S&larr;&empty;
 3. Q&larr;V [G]
 4. while Q &ne; &empty;
 5. do u &larr; EXTRACT - MIN (Q)
 6. S &larr; S &cup; {u}
 7. for each vertex v &isin; Adj [u]
 8. do RELAX (u, v, w)
</pre>
</div>
<p><strong>Analysis:</strong>&nbsp;The running time of Dijkstra's algorithm on a graph with edges E and vertices V can be expressed as a function of |E| and |V| using the Big - O notation. The simplest implementation of the Dijkstra's algorithm stores vertices of set Q in an ordinary linked list or array, and operation Extract - Min (Q) is simply a linear search through all vertices in Q. In this case, the running time is O (|V<sup>2</sup>&nbsp;|+|E|=O(V<sup>2</sup>&nbsp;).</p>
<p><strong>Example:</strong></p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/dijkstra-algorithm.png" alt="Dijkstra's Algorithm" /></p>
<p><strong>Step1:</strong>&nbsp;Q =[s, t, x, y, z]</p>
<p>We scanned vertices one by one and find out its adjacent. Calculate the distance of each adjacent to the source vertices.</p>
<p>We make a stack, which contains those vertices which are selected after computation of shortest distance.</p>
<p>Firstly we take's' in stack M (which is a source)</p>
<div class="codeblock">
<div class="dp-highlighter">
<div class="bar">&nbsp;</div>
<ol class="dp-j" start="1">
<li class="alt">M&nbsp;=&nbsp;[S]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q&nbsp;=&nbsp;[t,&nbsp;x,&nbsp;y,&nbsp;z]&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p><strong>Step 2:</strong>&nbsp;Now find the adjacent of s that are t and y.</p>
<div class="codeblock">
<div class="dp-highlighter">
<div class="bar">&nbsp;</div>
<ol class="dp-j" start="1">
<li class="alt">Adj&nbsp;[s]&nbsp;&rarr;&nbsp;t,&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[Here&nbsp;s&nbsp;is&nbsp;u&nbsp;and&nbsp;t&nbsp;and&nbsp;y&nbsp;are&nbsp;v]&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p><br /><img src="https://static.javatpoint.com/tutorial/daa/images/dijkstra-algorithm2.png" alt="Dijkstra's Algorithm" /></p>
<p><strong>Case - (i)&nbsp;</strong>s &rarr; t<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [v] &gt; d [u] + w [u, v]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [t] &gt; d [s] + w [s, t]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &infin; &gt; 0 + 10&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [false condition]<br />Then &nbsp; &nbsp; &nbsp;&nbsp;<strong>d [t] &larr; 10</strong><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>&pi; [t] &larr; 5</strong><br />Adj [s] &larr; t, y</p>
<p><strong>Case - (ii)&nbsp;</strong>s&rarr; y<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [v] &gt; d [u] + w [u, v]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [y] &gt; d [s] + w [s, y]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &infin; &gt; 0 + 5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [false condition]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &infin; &gt; 5<br />Then &nbsp; &nbsp; &nbsp;&nbsp;<strong>d [y] &larr; 5</strong><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>&pi; [y] &larr; 5</strong></p>
<p>By comparing case (i) and case (ii)<br />&nbsp; &nbsp; &nbsp;Adj [s] &rarr; t = 10, y = 5<br />&nbsp; &nbsp; &nbsp;y is shortest<br /><strong>y is assigned in 5 = [s, y]</strong></p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/dijkstra-algorithm3.png" alt="Dijkstra's Algorithm" /></p>
<p><strong>Step 3:</strong>&nbsp;Now find the adjacent of y that is t, x, z.</p>
<div class="codeblock">
<div class="dp-highlighter">
<div class="bar">&nbsp;</div>
<ol class="dp-j" start="1">
<li class="alt">Adj&nbsp;[y]&nbsp;&rarr;&nbsp;t,&nbsp;x,&nbsp;z&nbsp;&nbsp;&nbsp;[Here&nbsp;y&nbsp;is&nbsp;u&nbsp;and&nbsp;t,&nbsp;x,&nbsp;z&nbsp;are&nbsp;v]&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p><strong>Case - (i)</strong>&nbsp;y &rarr;t<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [v] &gt; d [u] + w [u, v]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [t] &gt; d [y] + w [y, t]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10 &gt; 5 + 3<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10 &gt; 8<br />Then &nbsp; &nbsp; d [t] &larr; 8<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &pi; [t] &larr; y</p>
<p><strong>Case - (ii)</strong>&nbsp;y &rarr; x<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [v] &gt; d [u] + w [u, v]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [x] &gt; d [y] + w [y, x]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &infin; &gt; 5 + 9<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &infin; &gt; 14<br />Then &nbsp; &nbsp; &nbsp;d [x] &larr; 14<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&pi; [x] &larr; 14</p>
<p><strong>Case - (iii)</strong>&nbsp;y &rarr; z<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;d [v] &gt; d [u] + w [u, v]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;d [z] &gt; d [y] + w [y, z]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&infin; &gt; 5 + 2<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&infin; &gt; 7<br />Then&nbsp; &nbsp; &nbsp; d [z] &larr; 7<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&pi; [z] &larr; y</p>
<p>By comparing case (i), case (ii) and case (iii)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Adj [y] &rarr; x = 14, t = 8, z =7<br />z is shortest<br /><strong>z is assigned in 7 = [s, z]</strong></p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/dijkstra-algorithm4.png" alt="Dijkstra's Algorithm" /></p>
<p><strong>Step - 4 Now</strong>&nbsp;we will find adj [z] that are s, x</p>
<div class="codeblock">
<div class="dp-highlighter">
<div class="bar">&nbsp;</div>
<ol class="dp-j" start="1">
<li class="alt">Adj&nbsp;[z]&nbsp;&rarr;&nbsp;[x,&nbsp;s]&nbsp;&nbsp;&nbsp;&nbsp;[Here&nbsp;z&nbsp;is&nbsp;u&nbsp;and&nbsp;s&nbsp;and&nbsp;x&nbsp;are&nbsp;v]&nbsp;&nbsp;</li>
</ol>
</div>
</div>
<p><strong>Case - (i)</strong>&nbsp;z &rarr; x<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [v] &gt; d [u] + w [u, v]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [x] &gt; d [z] + w [z, x]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 14 &gt; 7 + 6<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 14 &gt; 13<br />Then &nbsp; &nbsp; &nbsp; d [x] &larr; 13<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &pi; [x] &larr; z</p>
<p><strong>Case - (ii)</strong>&nbsp;z &rarr; s<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [v] &gt; d [u] + w [u, v]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [s] &gt; d [z] + w [z, s]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &gt; 7 + 7<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 0 &gt; 14<br />&there4; This condition does not satisfy so it will be discarded.<br />Now we have x = 13.</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/dijkstra-algorithm5.png" alt="Dijkstra's Algorithm" /></p>
<p><strong>Step 5:</strong>&nbsp;Now we will find Adj [t]</p>
<p>Adj [t] &rarr; [x, y] [Here t is u and x and y are v]</p>
<p><strong>Case - (i)</strong>&nbsp;t &rarr; x<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [v] &gt; d [u] + w [u, v]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [x] &gt; d [t] + w [t, x]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 13 &gt; 8 + 1<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 13 &gt; 9<br /><strong>Then &nbsp; &nbsp; &nbsp; d [x] &larr; 9</strong><br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<strong>&pi; [x] &larr; t</strong></p>
<p><strong>Case - (ii)</strong>&nbsp;t &rarr; y<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [v] &gt; d [u] + w [u, v]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d [y] &gt; d [t] + w [t, y]<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5 &gt; 10<br />&there4; This condition does not satisfy so it will be discarded.</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/dijkstra-algorithm6.png" alt="Dijkstra's Algorithm" /></p>
<p>Thus we get all shortest path vertex as</p>
<p>Weight from s to y is 5<br />Weight from s to z is 7<br />Weight from s to t is 8<br />Weight from s to x is 9</p>
<p>These are the shortest distance from the source's' in the given graph.</p>
<p><img src="https://static.javatpoint.com/tutorial/daa/images/dijkstra-algorithm7.png" alt="Dijkstra's Algorithm" /></p>
<h2><strong><span style="text-decoration: underline;"><em><span style="color: #ff6600; text-decoration: underline;">9.Minimum Spanning Trees:</span></em></span></strong></h2>
<p><br />When a graph is connected, we may ask how many edges&nbsp;we can delete before it stops being connected. Depending&nbsp;on the edges we remove, this may happen sooner or later.&nbsp;The slowest strategy is to remove edges until the graph&nbsp;becomes a tree. Here we study the somewhat more difficult&nbsp;problem of removing edges with a maximum total&nbsp;weight. The remaining graph is then a tree with minimum&nbsp;total weight. Applications that motivate this question can&nbsp;be found in life support systems modeled as graphs or networks,&nbsp;such as telephone, power supply, and sewer systems.&nbsp;</p>
<h2>Prim's Algorithm :&nbsp;</h2>
<p>This algorithm is directly based on the MST property.</p>
<p>Assume tha<strong>t&nbsp;</strong><em>V</em>&nbsp;= {1, 2,...,&nbsp;<em>n</em>}<strong>.</strong><br /><strong>{</strong></p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; T =&nbsp;<img src="http://lcm.csa.iisc.ernet.in/dsa/img422.gif" alt="$ \phi$" width="20" height="45" align="CENTER" border="0" />;</strong></p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; U = { 1 };</strong></p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (</strong><em>U<img src="http://lcm.csa.iisc.ernet.in/dsa/img79.gif" alt="$ \neq$" width="24" height="45" align="CENTER" border="0" />V</em>)</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</strong></p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; let&nbsp;</strong>(<em>u</em>,&nbsp;<em>v</em>)<strong>&nbsp;</strong>be the lowest cost edge</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>such tha<strong>t&nbsp;</strong><em>u<img src="http://lcm.csa.iisc.ernet.in/dsa/img68.gif" alt="$ \in$" width="22" height="42" align="CENTER" border="0" />U</em><strong>&nbsp;</strong>and&nbsp;<em>v<img src="http://lcm.csa.iisc.ernet.in/dsa/img68.gif" alt="$ \in$" width="22" height="42" align="CENTER" border="0" />V</em>&nbsp;-&nbsp;<em>U</em><strong>;</strong></p>
<p><em>T</em>&nbsp;=&nbsp;<em>T<img src="http://lcm.csa.iisc.ernet.in/dsa/img320.gif" alt="$ \cup$" width="22" height="21" align="BOTTOM" border="0" /></em>&nbsp;{(<em>u</em>,&nbsp;<em>v</em>)}</p>
<p><em>U</em>&nbsp;=&nbsp;<em>U<img src="http://lcm.csa.iisc.ernet.in/dsa/img320.gif" alt="$ \cup$" width="22" height="21" align="BOTTOM" border="0" /></em>&nbsp;{<em>v</em>}</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></p>
<ul>
<li><em>O</em>(<em>n</em><sup>2</sup>) algorithm.</li>
</ul>
<p><strong>Proof of Correctness of Prim's Algorithm</strong></p>
<p><strong>Theorem:&nbsp;</strong>Prim's algorithm finds a minimum spanning tree.</p>
<p><strong>Proof:&nbsp;</strong>Let G = (V,E) be a weighted, connected graph. Let T be the edge set that is grown in Prim's algorithm. The proof is by mathematical induction on the number of edges in T and using the MST Lemma.</p>
<p><strong>Basis</strong>: The empty set&nbsp;<img src="http://lcm.csa.iisc.ernet.in/dsa/img422.gif" alt="$ \phi$" width="20" height="45" align="CENTER" border="0" />&nbsp;is promising since a connected, weighted graph always has at least one MST.</p>
<p><strong>Induction Step:&nbsp;</strong>Assume that T is promising just before the algorithm adds a new edge e = (u,v). Let U be the set of nodes grown in Prim's algorithm. Then all three conditions in the MST Lemma are satisfied and therefore T U e is also promising.</p>
<p>When the algorithm stops, U includes all vertices of the graph and hence T is a spanning tree. Since T is also promising, it will be a MST.</p>
<p><strong>Implementation of Prim's Algorithm</strong></p>
<p>Use two arrays,&nbsp;<strong>closest and lowcost.</strong></p>
<ul>
<ul>
<li>For&nbsp;<em>i</em>&nbsp;<img src="http://lcm.csa.iisc.ernet.in/dsa/img68.gif" alt="$ \in$" width="22" height="42" align="CENTER" border="0" /><em>V</em>&nbsp;-&nbsp;<em>U</em>, closest[<em>i</em>] gives the vertex in&nbsp;<em>U</em>&nbsp;that is closest to&nbsp;<em>i</em></li>
<li>For&nbsp;<em>i</em>&nbsp;<img src="http://lcm.csa.iisc.ernet.in/dsa/img68.gif" alt="$ \in$" width="22" height="42" align="CENTER" border="0" /><em>V</em>&nbsp;-&nbsp;<em>U</em>, lowcost[<em>i</em>] gives the cost of the edge (<em>i</em>, closest(<em>i</em>))</li>
</ul>
</ul>
<center><a name="fig:prim1"></a><a name="12720"></a></center><center>
<table width="50%"><caption><strong>Figure 8.11:</strong>&nbsp;Illustration of Prim's algorithm</caption>
<tbody>
<tr>
<td><img src="http://lcm.csa.iisc.ernet.in/dsa/img425.gif" alt="\begin{figure}\centerline{\psfig{figure=figures/Fprim1.ps,width=6.0in}}\end{figure}" width="1033" height="833" /></td>
</tr>
</tbody>
</table>
</center><center>
<p><a name="fig:prim2"></a><a name="12725"></a></p>
</center><center>
<table width="50%"><caption><strong>Figure 8.12:</strong>&nbsp;An example graph for illustrating Prim's algorithm</caption>
<tbody>
<tr>
<td><img src="http://lcm.csa.iisc.ernet.in/dsa/img426.gif" alt="\begin{figure}\centerline{\psfig{figure=figures/Fprim2.ps,width=2in}}\end{figure}" width="344" height="350" /></td>
</tr>
</tbody>
</table>
</center>
<ul>
<li>At each step, we can scan lowcost to find the vertex in&nbsp;<em>V</em>&nbsp;-&nbsp;<em>U</em>&nbsp;that is closest to&nbsp;<em>U</em>. Then we update lowcost and closest taking into account the new addition to&nbsp;<em>U</em>.</li>
<li>Complexity:&nbsp;<em>O</em>(<em>n</em><sup>2</sup>)</li>
</ul>
<p><strong>Example:&nbsp;</strong>Consider the digraph shown in Figure&nbsp;<a href="http://lcm.csa.iisc.ernet.in/dsa/node183.html#fig:prim2">8.12</a>.</p>
<table cellpadding="3">
<tbody>
<tr>
<td colspan="3" align="CENTER"><img src="http://lcm.csa.iisc.ernet.in/dsa/img427.gif" alt="\fbox{Step 1}" width="79" height="35" align="BOTTOM" border="0" /></td>
</tr>
<tr>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr>
<td colspan="2" align="CENTER"><em>U</em>&nbsp;= {1}</td>
<td align="CENTER"><em>V</em>&nbsp;-&nbsp;<em>U</em>&nbsp;= {2, 3, 4, 5, 6}</td>
</tr>
<tr>
<td colspan="2" align="CENTER">closest</td>
<td align="CENTER">lowcost</td>
</tr>
<tr>
<td align="CENTER"><em>V</em>&nbsp;-&nbsp;<em>U</em></td>
<td align="CENTER"><em>U</em></td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr>
<td align="CENTER">2</td>
<td align="CENTER">1</td>
<td style="text-align: center;" align="CENTER">6</td>
</tr>
<tr>
<td align="CENTER">3</td>
<td align="CENTER">1</td>
<td align="CENTER">1</td>
</tr>
<tr>
<td align="CENTER">4</td>
<td align="CENTER">1</td>
<td align="CENTER">5</td>
</tr>
<tr>
<td align="CENTER">5</td>
<td align="CENTER">1</td>
<td align="CENTER"><img src="http://lcm.csa.iisc.ernet.in/dsa/img347.gif" alt="$ \infty$" width="30" height="21" align="BOTTOM" border="0" /></td>
</tr>
<tr>
<td align="CENTER">6</td>
<td align="CENTER">1</td>
<td align="CENTER"><img src="http://lcm.csa.iisc.ernet.in/dsa/img347.gif" alt="$ \infty$" width="30" height="21" align="BOTTOM" border="0" /></td>
</tr>
</tbody>
</table>
<p>Select vertex 3 to include in&nbsp;<strong><em>U</em></strong></p>
<table cellpadding="3">
<tbody>
<tr>
<td colspan="3" align="CENTER"><img src="http://lcm.csa.iisc.ernet.in/dsa/img428.gif" alt="\fbox{Step 2}" width="79" height="35" align="BOTTOM" border="0" /></td>
</tr>
<tr>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr>
<td colspan="2" align="CENTER"><em>U</em>&nbsp;= {1, 3}</td>
<td align="CENTER"><em>V</em>&nbsp;-&nbsp;<em>U</em>&nbsp;= {2, 4, 5, 6}</td>
</tr>
<tr>
<td colspan="2" align="CENTER">closest</td>
<td align="CENTER">lowcost</td>
</tr>
<tr>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr>
<td align="CENTER"><em>V</em>&nbsp;-&nbsp;<em>U</em></td>
<td align="CENTER"><em>U</em></td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr>
<td align="CENTER">2</td>
<td align="CENTER">3</td>
<td align="CENTER">5</td>
</tr>
<tr>
<td align="CENTER">4</td>
<td align="CENTER">1</td>
<td align="CENTER">5</td>
</tr>
<tr>
<td align="CENTER">5</td>
<td align="CENTER">3</td>
<td align="CENTER">6</td>
</tr>
<tr>
<td align="CENTER">6</td>
<td align="CENTER">3</td>
<td align="CENTER">4</td>
</tr>
<tr>
<td colspan="3" align="LEFT">Now select vertex 6</td>
</tr>
</tbody>
</table>
<table cellpadding="3">
<tbody>
<tr>
<td colspan="3" align="CENTER"><img src="http://lcm.csa.iisc.ernet.in/dsa/img429.gif" alt="\fbox{Step3}" width="79" height="35" align="BOTTOM" border="0" /></td>
</tr>
<tr>
<td colspan="2" align="CENTER"><em>U</em>&nbsp;= {1, 3, 6}</td>
<td align="CENTER"><em>V</em>&nbsp;-&nbsp;<em>U</em>&nbsp;= {2, 4, 5, 6}</td>
</tr>
<tr>
<td colspan="2" align="CENTER">closest</td>
<td align="CENTER">lowcost</td>
</tr>
<tr>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr>
<td align="CENTER"><em>V</em>&nbsp;-&nbsp;<em>U</em></td>
<td align="CENTER"><em>U</em></td>
<td align="CENTER">&nbsp;</td>
</tr>
<tr>
<td align="CENTER">2</td>
<td align="CENTER">3</td>
<td align="CENTER">5</td>
</tr>
<tr>
<td align="CENTER">4</td>
<td align="CENTER">6</td>
<td align="CENTER">2</td>
</tr>
<tr>
<td align="CENTER">5</td>
<td align="CENTER">3</td>
<td align="CENTER">6</td>
</tr>
<tr>
<td colspan="3" align="CENTER">Now select vertex 4, and so on</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<h2>&nbsp;Kruskal's Algorithm</h2>
<ul>
<ul>
<li>Complexity is&nbsp;<em>O</em>(<em>e</em>log&nbsp;<em>e</em>) where&nbsp;<em>e</em>&nbsp;is the number of edges. Can be made even more efficient by a proper choice of data structures.</li>
<li>Greedy algorithm</li>
<li>Algorithm</li>
</ul>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Let G = (V, E) be the given graph, with | V| = n</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;{</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Start with a graph&nbsp;<em>T</em>&nbsp;= (<em>V</em>,<img src="http://lcm.csa.iisc.ernet.in/dsa/img422.gif" alt="$ \phi$" width="20" height="45" align="CENTER" border="0" />) consisting of only the</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vertices of&nbsp;<em>G</em>&nbsp;and no edges; /<tt>*</tt>&nbsp;This can be viewed as&nbsp;<em>n</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connected components, each vertex being one connected component&nbsp;<tt>*</tt>/</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Arrange E in the order of increasing costs;</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for</strong>&nbsp;(<em>i</em>&nbsp;= 1,&nbsp;<em>i<img src="http://lcm.csa.iisc.ernet.in/dsa/img18.gif" alt="$ \leq$" width="25" height="42" align="CENTER" border="0" />n</em>&nbsp;- 1,&nbsp;<em>i</em>&nbsp;+ +)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { Select the next smallest cost edge;</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if</strong>&nbsp;(the edge connects two different connected components)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add the edge to&nbsp;<em>T</em>;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; }&nbsp;</p>
<ul>
<ul>
<li>At the end of the algorithm, we will be left with a single component that comprises all the vertices and this component will be an MST for G.&nbsp;<strong>Proof of Correctness of Kruskal's Algorith</strong></li>
</ul>
</ul>
<p><strong>Theorem:</strong>&nbsp;Kruskal's algorithm finds a minimum spanning tree.</p>
<p><strong>Proof:</strong>&nbsp;Let G = (V, E) be a weighted, connected graph. Let T be the edge set that is grown in Kruskal's algorithm. The proof is by mathematical induction on the number of edges in T.</p>
<ul>
<ul>
<ul>
<li>We show that if T is promising at any stage of the algorithm, then it is still promising when a new edge is added to it in Kruskal's algorithm</li>
<li>When the algorithm terminates, it will happen that T gives a solution to the problem and hence an MST.</li>
</ul>
</ul>
</ul>
<p><strong>Induction Step:</strong>&nbsp;Let T be promising just before adding a new edge&nbsp;<em>e</em>&nbsp;= (<em>u</em>,&nbsp;<em>v</em>). The edges T divide the nodes of G into one or more connected components. u and v will be in two different components. Let U be the set of nodes in the component that includes u. Note that</p>
<ul>
<ul>
<ul>
<li>U is a strict subset of V</li>
<li>T is a promising set of edges such that no edge in T leaves U (since an edge T either has both ends in U or has neither end in U)</li>
<li>e is a least cost edge that leaves U (since Kruskal's algorithm, being greedy, would have chosen e only after examining edges shorter than e)</li>
</ul>
The above three conditions are precisely like in the MST Lemma and hence we can conclude that the&nbsp;</ul>
</ul>
<em>T<img src="http://lcm.csa.iisc.ernet.in/dsa/img320.gif" alt="$ \cup$" width="22" height="21" align="BOTTOM" border="0" /></em>
<ul>
<ul>&nbsp;{</ul>
</ul>
<em>e</em>
<ul>
<ul>} is also promising. When the algorithm stops, T gives not merely a spanning tree but a minimal spanning tree since it is promising.</ul>
</ul>
<br />
<ul>
<ul>&nbsp;</ul>
</ul>
<center>
<p><a name="fig:kruskal"></a><a name="12792"></a></p>
</center><center>
<table width="50%"><caption><strong>Figure 8.13:</strong>&nbsp;An illustration of Kruskal's algorithm</caption>
<tbody>
<tr>
<td><img src="http://lcm.csa.iisc.ernet.in/dsa/img430.gif" alt="\begin{figure}\centerline{\psfig{figure=figures/Fkruskal.ps,width=5.5in}}\end{figure}" width="714" height="839" /></td>
</tr>
</tbody>
</table>
</center>
<ul>
<li><strong>Program</strong></li>
</ul>
<hr width="100%" />
<p><br /><strong>void&nbsp;</strong>kruskal<strong>&nbsp;</strong>(vertex-set<strong>&nbsp;</strong><em>V</em><strong>;</strong>&nbsp;edge-set&nbsp;<em>E</em><strong>;&nbsp;</strong>edge-set<strong>&nbsp;</strong><em>T</em><strong>)</strong></p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;</strong>ncomp; /* current number of components */</p>
<p>&nbsp;&nbsp;&nbsp; priority-queue edges /* partially ordered tree */</p>
<p>&nbsp;&nbsp;&nbsp; mfset components; /* merge-find set data structure */</p>
<p><strong>&nbsp;&nbsp;&nbsp;</strong>&nbsp;vertex<strong>&nbsp;</strong><em>u</em>,&nbsp;<em>v</em><strong>;&nbsp;</strong>edge e<strong>;</strong></p>
<p><strong>&nbsp;&nbsp;&nbsp; int&nbsp;</strong>nextcomp; /* name for new component */</p>
<p><strong>&nbsp;&nbsp;&nbsp; int</strong>&nbsp;ucomp, vcomp; /* component names */</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; makenull (T); makenull (edges);</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>&nbsp;&nbsp;&nbsp; nextcomp = 0; ncomp<strong>&nbsp;=&nbsp;</strong><em>n</em><strong>;</strong></p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for&nbsp;</strong>(<em>v<img src="http://lcm.csa.iisc.ernet.in/dsa/img68.gif" alt="$ \in$" width="22" height="42" align="CENTER" border="0" />V</em>)<strong>&nbsp;/</strong><tt>*</tt><strong>&nbsp;</strong>initialize a component to have one vertex of<strong>&nbsp;</strong><em>V</em><tt>*</tt><strong>/</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { nextcomp++ ;</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>&nbsp;&nbsp; initial (nextcomp,<strong>&nbsp;</strong><em>v</em><strong>,&nbsp;</strong>components);</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</strong></p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for&nbsp;</strong>(<em>e<img src="http://lcm.csa.iisc.ernet.in/dsa/img68.gif" alt="$ \in$" width="22" height="42" align="CENTER" border="0" />E</em>)</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; insert&nbsp;</strong>(<em>e</em><strong>,&nbsp;</strong>edges); /* initialize priority queue of edges */</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while&nbsp;</strong>(ncomp &gt; 1)</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</strong></p>
<p><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e</em><strong>&nbsp;=&nbsp;</strong>deletemin (edges);</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>&nbsp;&nbsp;&nbsp;&nbsp; let<strong>&nbsp;</strong><em>e</em>&nbsp;= (<em>u</em>,&nbsp;<em>v</em>)<strong>;</strong></p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>&nbsp;&nbsp; ucomp = find<strong>(</strong><em>u</em><strong>,&nbsp;</strong>components);</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>&nbsp; vcomp = find<strong>(</strong><em>v</em><strong>,&nbsp;</strong>components);</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if</strong>&nbsp;(ucomp! = vcomp)</p>
<p><strong>&nbsp;&nbsp;</strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; merge (ucomp, vcomp, components);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ncomp = ncomp - 1;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp; }</p>
<hr width="100%" />
<p><strong>Implementation</strong></p>
<ul>
<ul>
<li>Choose a partially ordered tree for representing the sorted set of edges</li>
<li>To represent connected components and interconnecting them, we need to implement:</li>
</ul>
</ul>
<dl compact="compact">
<dt>1.</dt>
<dd>MERGE (A, B, C) . . . merge components A and B in C and call the result A or B arbitrarily.</dd>
<dt>2.</dt>
<dd>FIND (<em>v</em>, C) . . . returns the name of the component of C of which vertex&nbsp;<em>v</em>&nbsp;is a member. This operation will be used to determine whether the two vertices of an edge are in the same or in different components.</dd>
<dt>3.</dt>
<dd>INITIAL (A,&nbsp;<em>v</em>, C) . . . makes A the name of the component in C containing only one vertex, namely&nbsp;<em>v</em></dd>
</dl>
<ul>
<li>The above data structure is called an MFSET</li>
</ul>
<p><strong>Running Time of Kruskal's Algorithm</strong></p>
<ul>
<ul>
<li>Creation of the priority queue</li>
</ul>
</ul>
<dl compact="compact">
<dt><tt>*</tt></dt>
<dd>If there are&nbsp;<em>e</em>&nbsp;edges, it is easy to see that it takes&nbsp;<em>O</em>(<em>e</em>log&nbsp;<em>e</em>) time to insert the edges into a partially ordered tree</dd>
<dt><tt>*</tt></dt>
<dd><em>O</em>(<em>e</em>) algorithms are possible for this problem</dd>
</dl>
<ul>
<ul>
<li>Each deletemin operation takes&nbsp;<em>O</em>(log&nbsp;<em>e</em>) time in the worst case. Thus finding and deleting least-cost edges, over the while iterations contribute&nbsp;<em>O</em>(log&nbsp;<em>e</em>) in the worst case.</li>
<li>The total time for performing all the merge and find depends on the method used.</li>
</ul>
</ul>
<table cellpadding="3">
<tbody>
<tr>
<td align="LEFT"><em>O</em>(<em>e</em>log&nbsp;<em>e</em>)</td>
<td align="LEFT">without path compression</td>
</tr>
<tr>
<td align="LEFT"><em>O</em>(<em>e<img src="http://lcm.csa.iisc.ernet.in/dsa/img54.gif" alt="$ \alpha$" width="21" height="21" align="BOTTOM" border="0" /></em>(<em>e</em>))</td>
<td align="LEFT">with the path compression, where</td>
</tr>
<tr>
<td align="LEFT"><img src="http://lcm.csa.iisc.ernet.in/dsa/img54.gif" alt="$ \alpha$" width="21" height="21" align="BOTTOM" border="0" />(<em>e</em>)</td>
<td align="LEFT">is the inverse of an Ackerman function.</td>
</tr>
</tbody>
</table>
<p><strong>Example: See Figure&nbsp;<a href="http://lcm.csa.iisc.ernet.in/dsa/node184.html#fig:kruskal">8.13</a>.</strong></p>
<p><strong>E = {(1,3), (4,6), (2,5), (3,6), (3,4), (1,4), (2,3), (1,2), (3,5), (5,6) }</strong></p>
<p>&nbsp;</p>
<h1><span style="background-color: #ffff00;">IV.TOPOLOGICAL SORTING</span></h1>
<p>Topological sorting of vertices of a&nbsp;<strong>Directed Acyclic Graph</strong>&nbsp;is an ordering of the vertices&nbsp;<span id="MathJax-Element-1-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">v1,v2,...vn</span></span>&nbsp;in such a way, that if there is an edge directed towards vertex&nbsp;<span id="MathJax-Element-2-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vj</span></span>&nbsp;from vertex&nbsp;<span id="MathJax-Element-3-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vi</span></span>, then&nbsp;<span id="MathJax-Element-4-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vi</span></span>&nbsp;comes before&nbsp;<span id="MathJax-Element-5-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vj</span></span>. For example consider the graph given below:</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://he-s3.s3.amazonaws.com/media/uploads/d6be27e.png" alt="enter image description here" /></p>
<p>A topological sorting of this graph is:&nbsp;<span id="MathJax-Element-6-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">1</span></span>&nbsp;<span id="MathJax-Element-7-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">2</span></span>&nbsp;<span id="MathJax-Element-8-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">3</span></span>&nbsp;<span id="MathJax-Element-9-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">4</span></span>&nbsp;<span id="MathJax-Element-10-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">5</span></span><br />There are multiple topological sorting possible for a graph. For the graph given above one another topological sorting is:&nbsp;<span id="MathJax-Element-11-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">1</span></span>&nbsp;<span id="MathJax-Element-12-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">2</span></span>&nbsp;<span id="MathJax-Element-13-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">3</span></span>&nbsp;<span id="MathJax-Element-14-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">5</span></span>&nbsp;<span id="MathJax-Element-15-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">4</span></span><br />In order to have a topological sorting the graph must not contain any cycles. In order to prove it, let's assume there is a cycle made of the vertices&nbsp;<span id="MathJax-Element-16-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;mo&gt;.&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">v1,v2,v3...vn</span></span>. That means there is a directed edge between&nbsp;<span id="MathJax-Element-17-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vi</span></span>&nbsp;and&nbsp;<span id="MathJax-Element-18-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vi+1</span></span>&nbsp;<span id="MathJax-Element-19-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mo stretchy=&quot;false&quot;&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;&amp;#x2264;&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;&amp;#x003C;&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;)&lt;/mo&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">(1&le;i&lt;n)</span></span>&nbsp;and between&nbsp;<span id="MathJax-Element-20-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vn</span></span>&nbsp;and&nbsp;<span id="MathJax-Element-21-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">v1</span></span>. So now, if we do topological sorting then&nbsp;<span id="MathJax-Element-22-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vn</span></span>&nbsp;must come before&nbsp;<span id="MathJax-Element-23-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">v1</span></span>&nbsp;because of the directed edge from&nbsp;<span id="MathJax-Element-24-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vn</span></span>&nbsp;to&nbsp;<span id="MathJax-Element-25-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">v1</span></span>. Clearly,&nbsp;<span id="MathJax-Element-26-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vi+1</span></span>&nbsp;will come after&nbsp;<span id="MathJax-Element-27-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vi</span></span>, because of the directed from&nbsp;<span id="MathJax-Element-28-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vi</span></span>&nbsp;to&nbsp;<span id="MathJax-Element-29-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vi+1</span></span>, that means&nbsp;<span id="MathJax-Element-30-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">v1</span></span>&nbsp;must come before&nbsp;<span id="MathJax-Element-31-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vn</span></span>. Well, clearly we've reached a contradiction, here. So topological sorting can be achieved for only directed and acyclic graphs.</p>
<p>Le'ts see how we can find a topological sorting in a graph. So basically we want to find a permutation of the vertices in which for every vertex&nbsp;<span id="MathJax-Element-32-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vi</span></span>, all the vertices&nbsp;<span id="MathJax-Element-33-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vj</span></span>&nbsp;having edges coming out and directed towards&nbsp;<span id="MathJax-Element-34-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vi</span></span>&nbsp;comes before&nbsp;<span id="MathJax-Element-35-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vi</span></span>. We'll maintain an array&nbsp;<span id="MathJax-Element-36-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">T</span></span>&nbsp;that will denote our topological sorting. So, let's say for a graph having&nbsp;<span id="MathJax-Element-37-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">N</span></span>&nbsp;vertices, we have an array&nbsp;<span id="MathJax-Element-38-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x005F;&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">in_degree[]</span></span>&nbsp;of size&nbsp;<span id="MathJax-Element-39-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;N&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">N</span></span>&nbsp;whose&nbsp;<span id="MathJax-Element-40-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msup&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mrow class=&quot;MJX-TeXAtom-ORD&quot;&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">ith</span></span>&nbsp;element tells the number of vertices which are not already inserted in&nbsp;<span id="MathJax-Element-41-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">T</span></span>&nbsp;and there is an edge from them incident on vertex numbered&nbsp;<span id="MathJax-Element-42-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">i</span></span>. We'll append vertices&nbsp;<span id="MathJax-Element-43-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vi</span></span>&nbsp;to the array&nbsp;<span id="MathJax-Element-44-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">T</span></span>, and when we do that we'll decrease the value of&nbsp;<span id="MathJax-Element-45-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x005F;&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">in_degree[vj]</span></span>&nbsp;by&nbsp;<span id="MathJax-Element-46-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">1</span></span>&nbsp;for every edge from&nbsp;<span id="MathJax-Element-47-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vi</span></span>&nbsp;to&nbsp;<span id="MathJax-Element-48-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vj</span></span>. Doing this will mean that we have inserted one vertex having edge directed towards&nbsp;<span id="MathJax-Element-49-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;msub&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">vj</span></span>. So at any point we can insert only those vertices for which the value of&nbsp;<span id="MathJax-Element-50-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x005F;&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">in_degree[]</span></span>&nbsp;is&nbsp;<span id="MathJax-Element-51-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">0</span></span>.<br />The algorithm using a BFS traversal is given below:</p>
<pre class="prettyprint prettyprinted"><code><span class="pln">topological_sort</span><span class="pun">(</span><span class="pln">N</span><span class="pun">,</span><span class="pln"> adj</span><span class="pun">[</span><span class="pln">N</span><span class="pun">][</span><span class="pln">N</span><span class="pun">])</span><span class="pln">
        T </span><span class="pun">=</span> <span class="pun">[]</span><span class="pln">
        visited </span><span class="pun">=</span> <span class="pun">[]</span><span class="pln">
        in_degree </span><span class="pun">=</span> <span class="pun">[]</span>
        <span class="kwd">for</span><span class="pln"> i </span><span class="pun">=</span> <span class="lit">0</span><span class="pln"> to N
                in_degree</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span> <span class="pun">=</span><span class="pln"> visited</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span> <span class="pun">=</span> <span class="lit">0</span>

        <span class="kwd">for</span><span class="pln"> i </span><span class="pun">=</span> <span class="lit">0</span><span class="pln"> to N
                </span><span class="kwd">for</span><span class="pln"> j </span><span class="pun">=</span> <span class="lit">0</span><span class="pln"> to N
                        </span><span class="kwd">if</span><span class="pln"> adj</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span> <span class="kwd">is</span><span class="pln"> TRUE
                                in_degree</span><span class="pun">[</span><span class="pln">j</span><span class="pun">]</span> <span class="pun">=</span><span class="pln"> in_degree</span><span class="pun">[</span><span class="pln">j</span><span class="pun">]</span> <span class="pun">+</span> <span class="lit">1</span>

        <span class="kwd">for</span><span class="pln"> i </span><span class="pun">=</span> <span class="lit">0</span><span class="pln"> to N
                </span><span class="kwd">if</span><span class="pln"> in_degree</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span> <span class="kwd">is</span> <span class="lit">0</span><span class="pln">
                        enqueue</span><span class="pun">(</span><span class="typ">Queue</span><span class="pun">,</span><span class="pln"> i</span><span class="pun">)</span><span class="pln">
                        visited</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span> <span class="pun">=</span><span class="pln"> TRUE

        </span><span class="kwd">while</span> <span class="typ">Queue</span> <span class="kwd">is</span> <span class="kwd">not</span> <span class="typ">Empty</span><span class="pln">
                vertex </span><span class="pun">=</span><span class="pln"> get_front</span><span class="pun">(</span><span class="typ">Queue</span><span class="pun">)</span><span class="pln">
                dequeue</span><span class="pun">(</span><span class="typ">Queue</span><span class="pun">)</span><span class="pln">
                T</span><span class="pun">.</span><span class="pln">append</span><span class="pun">(</span><span class="pln">vertex</span><span class="pun">)</span>
                <span class="kwd">for</span><span class="pln"> j </span><span class="pun">=</span> <span class="lit">0</span><span class="pln"> to N
                        </span><span class="kwd">if</span><span class="pln"> adj</span><span class="pun">[</span><span class="pln">vertex</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span> <span class="kwd">is</span><span class="pln"> TRUE </span><span class="kwd">and</span><span class="pln"> visited</span><span class="pun">[</span><span class="pln">j</span><span class="pun">]</span> <span class="kwd">is</span><span class="pln"> FALSE
                                in_degree</span><span class="pun">[</span><span class="pln">j</span><span class="pun">]</span> <span class="pun">=</span><span class="pln"> in_degree</span><span class="pun">[</span><span class="pln">j</span><span class="pun">]</span> <span class="pun">-</span> <span class="lit">1</span>
                                <span class="kwd">if</span><span class="pln"> in_degree</span><span class="pun">[</span><span class="pln">j</span><span class="pun">]</span> <span class="kwd">is</span> <span class="lit">0</span><span class="pln">
                                        enqueue</span><span class="pun">(</span><span class="typ">Queue</span><span class="pun">,</span><span class="pln"> j</span><span class="pun">)</span><span class="pln">
                                        visited</span><span class="pun">[</span><span class="pln">j</span><span class="pun">]</span> <span class="pun">=</span><span class="pln"> TRUE
        </span><span class="kwd">return</span><span class="pln"> T</span></code></pre>
<p>Let's take a graph and see the algorithm in action. Consider the graph given below:</p>
<center><img src="https://he-s3.s3.amazonaws.com/media/uploads/0c3320c.png" alt="enter image description here" /></center>
<p><br />Initially&nbsp;<span id="MathJax-Element-52-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x005F;&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">in_degree[0]=0</span></span>&nbsp;and&nbsp;<span id="MathJax-Element-53-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">T</span></span>&nbsp;is empty</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<center><img src="https://he-s3.s3.amazonaws.com/media/uploads/401c3c4.png" alt="enter image description here" /></center>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>So, we delete&nbsp;<span id="MathJax-Element-54-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">0</span></span>&nbsp;from&nbsp;<span id="MathJax-Element-55-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;Q&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">Queue</span></span>&nbsp;and append it to&nbsp;<span id="MathJax-Element-56-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">T</span></span>. The vertices directly connected to&nbsp;<span id="MathJax-Element-57-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">0</span></span>&nbsp;are&nbsp;<span id="MathJax-Element-58-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">1</span></span>&nbsp;and&nbsp;<span id="MathJax-Element-59-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">2</span></span>&nbsp;so we decrease their&nbsp;<span id="MathJax-Element-60-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x005F;&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">in_degree[]</span></span>&nbsp;by&nbsp;<span id="MathJax-Element-61-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">1</span></span>. So, now&nbsp;<span id="MathJax-Element-62-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x005F;&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">in_degree[1]=0</span></span>&nbsp;and so&nbsp;<span id="MathJax-Element-63-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">1</span></span>&nbsp;is pushed in&nbsp;<span id="MathJax-Element-64-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;Q&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">Queue</span></span>.</p>
<p>&nbsp;</p>
<center><img src="https://he-s3.s3.amazonaws.com/media/uploads/4aed1a4.png" alt="enter image description here" /></center>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Next we delete&nbsp;<span id="MathJax-Element-65-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">1</span></span>&nbsp;from&nbsp;<span id="MathJax-Element-66-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;Q&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">Queue</span></span>&nbsp;and append it to&nbsp;<span id="MathJax-Element-67-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">T</span></span>. Doing this we decrease&nbsp;<span id="MathJax-Element-68-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x005F;&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">in_degree[2]</span></span>&nbsp;by&nbsp;<span id="MathJax-Element-69-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">1</span></span>, and now it becomes&nbsp;<span id="MathJax-Element-70-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">0</span></span>&nbsp;and&nbsp;<span id="MathJax-Element-71-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">2</span></span>&nbsp;is pushed into&nbsp;<span id="MathJax-Element-72-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;Q&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">Queue</span></span>.</p>
<p>&nbsp;</p>
<center><img src="https://he-s3.s3.amazonaws.com/media/uploads/54d23c8.png" alt="enter image description here" /></center>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>So, we continue doing like this, and further iterations looks like as follows:</p>
<p>&nbsp;</p>
<center><img src="https://he-s3.s3.amazonaws.com/media/uploads/ccb8663.png" alt="enter image description here" /></center>
<p>&nbsp;</p>
<p>So at last we get our Topological sorting in&nbsp;<span id="MathJax-Element-73-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">T</span></span>&nbsp;i.e. :&nbsp;<span id="MathJax-Element-74-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">0</span></span>,&nbsp;<span id="MathJax-Element-75-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">1</span></span>,&nbsp;<span id="MathJax-Element-76-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">2</span></span>,&nbsp;<span id="MathJax-Element-77-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">3</span></span>,&nbsp;<span id="MathJax-Element-78-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">4</span></span>,&nbsp;<span id="MathJax-Element-79-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">5</span></span></p>
<p>Solution using a DFS traversal, unlike the one using BFS, does not need any special&nbsp;<span id="MathJax-Element-80-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi mathvariant=&quot;normal&quot;&gt;&amp;#x005F;&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo stretchy=&quot;false&quot;&gt;[&lt;/mo&gt;&lt;mo stretchy=&quot;false&quot;&gt;]&lt;/mo&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">in_degree[]</span></span>&nbsp;array. Following is the pseudo code of the DFS solution:</p>
<p>&nbsp;</p>
<pre class="prettyprint prettyprinted"><code><span class="pln">T </span><span class="pun">=</span> <span class="pun">[]</span><span class="pln">
visited </span><span class="pun">=</span> <span class="pun">[]</span><span class="pln">

topological_sort</span><span class="pun">(</span><span class="pln"> cur_vert</span><span class="pun">,</span><span class="pln"> N</span><span class="pun">,</span><span class="pln"> adj</span><span class="pun">[][]</span> <span class="pun">){</span><span class="pln">
    visited</span><span class="pun">[</span><span class="pln">cur_vert</span><span class="pun">]</span> <span class="pun">=</span> <span class="kwd">true</span>
    <span class="kwd">for</span><span class="pln"> i </span><span class="pun">=</span> <span class="lit">0</span><span class="pln"> to N
        </span><span class="kwd">if</span><span class="pln"> adj</span><span class="pun">[</span><span class="pln">cur_vert</span><span class="pun">][</span><span class="pln">i</span><span class="pun">]</span> <span class="kwd">is</span> <span class="kwd">true</span> <span class="kwd">and</span><span class="pln"> visited</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span> <span class="kwd">is</span> <span class="kwd">false</span><span class="pln">
        topological_sort</span><span class="pun">(</span><span class="pln">i</span><span class="pun">)</span><span class="pln">
    T</span><span class="pun">.</span><span class="pln">insert_in_beginning</span><span class="pun">(</span><span class="pln">cur_vert</span><span class="pun">)</span>
<span class="pun">}</span>
</code></pre>
<p>The following image of shows the state of stack and of array&nbsp;<span id="MathJax-Element-81-Frame" class="MathJax_SVG" tabindex="0" role="presentation" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/math&gt;"><span class="MJX_Assistive_MathML" role="presentation">T</span></span>&nbsp;in the above code for the same graph shown above.</p>
<p>////IMAGE</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1><span style="text-decoration: underline;"><em><strong><span style="background-color: #ffff00;">V. DYNAMIC PROGRAMMING</span></strong></em></span></h1>
<p><span style="text-decoration: underline;"><em><strong><span style="background-color: #ffff00;"><code><span class="pun"><img style="display: block; margin-left: auto; margin-right: auto;" src="https://he-s3.s3.amazonaws.com/media/uploads/6b68f98.png" alt="Yes, this is DP for you!" /></span></code></span></strong></em></span></p>
<p>The image above says a lot about Dynamic Programming. So, is repeating the things for which you already have the answer, a good thing ? A programmer would disagree. That's what Dynamic Programming is about. To&nbsp;<em>always</em>&nbsp;remember answers to the sub-problems you've already solved.</p>
<p>Let us say that we have a machine, and to determine its state at time&nbsp;<strong>t</strong>, we have certain quantities called state&nbsp;<strong>variables.</strong>&nbsp;There will be certain times when we have to make a decision which affects the state of the system, which may or may not be known to us in advance. These decisions or changes are equivalent to transformations of state variables. The results of the previous decisions help us in choosing the future ones.</p>
<p>What do we conclude from this? We need to break up a problem into a series of overlapping sub-problems, and build up solutions to larger and larger sub-problems. If you are given a problem, which can be broken down into smaller sub-problems, and these smaller sub-problems can still be broken into smaller ones - and if you manage to find out that there are some over-lappping sub-problems, then you've encountered a DP problem.</p>
<p>Some famous Dynamic Programming algorithms are:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Diff_utility">Unix diff</a>&nbsp;for comparing two files</li>
<li><a href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm">Bellman-Ford</a>&nbsp;for shortest path routing in networks</li>
<li><a href="http://en.wikipedia.org/wiki/TeX">TeX</a>&nbsp;the ancestor of LaTeX</li>
<li><a href="https://en.wikipedia.org/wiki/WASP_%28cricket_calculation_tool%29">WASP</a>&nbsp;- Winning and Score Predictor</li>
</ul>
<p>The core idea of Dynamic Programming is to avoid repeated work by remembering partial results and this concept finds it application in a lot of real life situations.</p>
<p>In programming, Dynamic Programming is a powerful technique that allows one to solve different types of problems in time O(n<sup>2</sup>) or O(n<sup>3</sup>) for which a naive approach would take exponential time.</p>
<p><a href="http://www.quora.com/Jonathan-Paulson">Jonathan Paulson</a>&nbsp;explains Dynamic Programming in his amazing Quora answer&nbsp;<a href="http://www.quora.com/How-should-I-explain-dynamic-programming-to-a-4-year-old/answer/Jonathan-Paulson">here.</a></p>
<blockquote>
<p>Writes down "1+1+1+1+1+1+1+1 =" on a sheet of paper.<br />"What's that equal to?"<br />Counting "Eight!"<br /><strong>Writes down another "1+" on the left.<br />"What about that?"</strong><br />"Nine!" " How'd you know it was nine so fast?"<br />"You just added one more!"<br />"So you didn't need to recount because you remembered there were eight! Dynamic Programming is just a fancy way to say remembering stuff to save time later!"</p>
</blockquote>
<hr />
<p><strong>Dynamic Programming and Recursion:</strong></p>
<p>Dynamic programming is basically, recursion plus using common sense. What it means is that recursion allows you to express the value of a function in terms of other values of that function. Where the common sense tells you that if you implement your function in a way that the recursive calls are done in advance, and stored for easy access, it will make your program faster. This is what we call Memoization - it is memorizing the results of some specific states, which can then be later accessed to solve other sub-problems.</p>
<p><strong>The intuition behind dynamic programming is that we trade space for time</strong>, i.e. to say that instead of calculating all the states taking a lot of time but no space, we take up space to store the results of all the sub-problems to save time later.</p>
<p>Let's try to understand this by taking an example of Fibonacci numbers.</p>
<blockquote>
<p>Fibonacci (n) = 1; if n = 0<br />Fibonacci (n) = 1; if n = 1<br />Fibonacci (n) = Fibonacci(n-1) + Fibonacci(n-2)</p>
</blockquote>
<p>So, the first few numbers in this series will be:&nbsp;<strong>1, 1, 2, 3, 5, 8, 13, 21...</strong>&nbsp;and so on!</p>
<p>A code for it using pure recursion:</p>
<pre class="prettyprint prettyprinted"><code>  <span class="kwd">int</span><span class="pln"> fib </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">)</span> <span class="pun">{</span>
        <span class="kwd">if</span> <span class="pun">(</span><span class="pln">n </span><span class="pun">&lt;</span> <span class="lit">2</span><span class="pun">)</span>
            <span class="kwd">return</span> <span class="lit">1</span><span class="pun">;</span>
        <span class="kwd">return</span><span class="pln"> fib</span><span class="pun">(</span><span class="pln">n</span><span class="pun">-</span><span class="lit">1</span><span class="pun">)</span> <span class="pun">+</span><span class="pln"> fib</span><span class="pun">(</span><span class="pln">n</span><span class="pun">-</span><span class="lit">2</span><span class="pun">);</span>
    <span class="pun">}</span></code></pre>
<p>Using Dynamic Programming approach with memoization:</p>
<pre class="prettyprint prettyprinted"><code> <span class="kwd">void</span><span class="pln"> fib </span><span class="pun">()</span> <span class="pun">{</span><span class="pln">
        fibresult</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span> <span class="pun">=</span> <span class="lit">1</span><span class="pun">;</span><span class="pln">
        fibresult</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span> <span class="pun">=</span> <span class="lit">1</span><span class="pun">;</span>
        <span class="kwd">for</span> <span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span> <span class="lit">2</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
           fibresult</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span> <span class="pun">=</span><span class="pln"> fibresult</span><span class="pun">[</span><span class="pln">i</span><span class="pun">-</span><span class="lit">1</span><span class="pun">]</span> <span class="pun">+</span><span class="pln"> fibresult</span><span class="pun">[</span><span class="pln">i</span><span class="pun">-</span><span class="lit">2</span><span class="pun">];</span>
    <span class="pun">}</span></code></pre>
<p>Are we using a different recurrence relation in the two codes? No. Are we doing anything different in the two codes? Yes.</p>
<p>In the recursive code, a lot of values are being recalculated multiple times. We could do good with calculating each unique quantity only once. Take a look at the image to understand that how certain values were being recalculated in the recursive way:<br /><img style="display: block; margin-left: auto; margin-right: auto;" src="http://ugweb.cs.ualberta.ca/~c274/web/ConcreteComputing/image/fib_tree.png" alt="enter image description here" /></p>
<hr />
<p>Majority of the Dynamic Programming problems can be categorized into two types:</p>
<p><strong>1. Optimization problems.<br />2. Combinatorial problems.</strong></p>
<p>The optimization problems expect you to select a feasible solution, so that the value of the required function is minimized or maximized. Combinatorial problems expect you to figure out the number of ways to do something, or the probability of some event happening.</p>
<p>Every Dynamic Programming problem has a schema to be followed:</p>
<ul>
<li>Show that the problem can be broken down into optimal sub-problems.</li>
<li>Recursively define the value of the solution by expressing it in terms of optimal solutions for smaller sub-problems.</li>
<li>Compute the value of the optimal solution in bottom-up fashion.</li>
<li>Construct an optimal solution from the computed information.</li>
</ul>
<p><strong>Bottom up vs. Top Down:</strong></p>
<ul>
<li><strong>Bottom Up</strong>&nbsp;- I'm going to learn programming. Then, I will start practicing. Then, I will start taking part in contests. Then, I'll practice even more and try to improve. After working hard like crazy, I'll be an amazing coder.</li>
<li><strong>Top Down</strong>&nbsp;- I will be an amazing coder. How? I will work hard like crazy. How? I'll practice more and try to improve. How? I'll start taking part in contests. Then? I'll practicing. How? I'm going to learn programming.</li>
</ul>
<p>Not a great example, but I hope I got my point across. In Top Down, you start building the big solution right away by explaining how you build it from smaller solutions. In Bottom Up, you start with the small solutions and then build up.</p>
<p>Memoization is very easy to code and might be your first line of approach for a while. Though, with dynamic programming, you don't risk blowing stack space, you end up with lots of liberty of when you can throw calculations away. The downside is that you have to come up with an ordering of a solution which works.</p>
<p><strong>One can think of dynamic programming as a table-filling algorithm: you know the calculations you have to do, so you pick the best order to do them in and ignore the ones you don't have to fill in.</strong></p>
<hr />
<p>Let's look at a sample problem:</p>
<blockquote>
<p>Let us say that you are given a number&nbsp;<strong>N,</strong>&nbsp;you've to find the number of different ways to write it as the sum of 1, 3 and 4.</p>
</blockquote>
<p>For example, if N = 5, the answer would be 6.</p>
<ul>
<li>1 + 1 + 1 + 1 + 1</li>
<li>1 + 4</li>
<li>4 + 1</li>
<li>1 + 1 + 3</li>
<li>1 + 3 + 1</li>
<li>3 + 1 + 1</li>
</ul>
<p><strong>Sub-problem:</strong>&nbsp;DP<sub>n</sub>&nbsp;be the number of ways to write&nbsp;<strong>N</strong>&nbsp;as the sum of 1, 3, and 4.<br /><strong>Finding recurrence:</strong>&nbsp;Consider one possible solution, n = x1 + x2 + ... x<sub>n</sub>. If the last number is 1, the sum of the remaining numbers should be n - 1. So, number of sums that end with 1 is equal to DP<sub>n-1.</sub>. Take other cases into account where the last number is 3 and 4. The final recurrence would be:</p>
<blockquote>
<p>DP<sub>n</sub>&nbsp;= DP<sub>n-1</sub>&nbsp;+ DP<sub>n-3</sub>&nbsp;+ DP<sub>n-4.</sub></p>
</blockquote>
<p>Take care of the base cases. DP<sub>0</sub>&nbsp;= DP<sub>1</sub>&nbsp;= DP<sub>2</sub>&nbsp;= 1, and DP<sub>3</sub>&nbsp;= 2.</p>
<p>Implementation:</p>
<pre class="prettyprint prettyprinted"><code><span class="pln"> DP</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span> <span class="pun">=</span><span class="pln"> DP</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span> <span class="pun">=</span><span class="pln"> DP</span><span class="pun">[</span><span class="lit">2</span><span class="pun">]</span> <span class="pun">=</span> <span class="lit">1</span><span class="pun">;</span><span class="pln"> DP</span><span class="pun">[</span><span class="lit">3</span><span class="pun">]</span> <span class="pun">=</span> <span class="lit">2</span><span class="pun">;</span>
    <span class="kwd">for</span> <span class="pun">(</span><span class="pln">i </span><span class="pun">=</span> <span class="lit">4</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;=</span><span class="pln"> n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span> <span class="pun">{</span><span class="pln">
      DP</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span> <span class="pun">=</span><span class="pln"> DP</span><span class="pun">[</span><span class="pln">i</span><span class="pun">-</span><span class="lit">1</span><span class="pun">]</span> <span class="pun">+</span><span class="pln"> DP</span><span class="pun">[</span><span class="pln">i</span><span class="pun">-</span><span class="lit">3</span><span class="pun">]</span> <span class="pun">+</span><span class="pln"> DP</span><span class="pun">[</span><span class="pln">i</span><span class="pun">-</span><span class="lit">4</span><span class="pun">];</span>
    <span class="pun">}</span></code></pre>
<p>The technique above, takes a bottom up approach and uses memoization to not compute results that have already been computed.</p>
<hr />
<p>I also want to share&nbsp;<a href="http://www.quora.com/Michal-Danil%C3%A1k">Michal's</a>&nbsp;amazing&nbsp;<a href="http://www.quora.com/Are-there-any-good-resources-or-tutorials-for-dynamic-programming-besides-the-TopCoder-tutorial/answer/Michal-Danil%C3%A1k?srid=3OBi&amp;share=1">answer on Dynamic Programming from Quora.</a></p>
<blockquote>
<p>"Imagine you have a collection of&nbsp;<strong>N</strong>&nbsp;wines placed next to each other on a shelf. For simplicity, let's number the wines from left to right as they are standing on the shelf with integers from&nbsp;<strong>1 to N</strong>, respectively. The price of the i<sup>th</sup>&nbsp;wine is pi. (prices of different wines can be different).</p>
<p>Because the wines get better every year, supposing today is the year 1, on year y the price of the i<sup>th</sup>&nbsp;wine will be y*pi, i.e. y-times the value that current year.</p>
<p>You want to sell all the wines you have, but you want to sell exactly one wine per year, starting on this year. One more constraint - on each year you are allowed to sell only either the leftmost or the rightmost wine on the shelf and you are not allowed to reorder the wines on the shelf (i.e. they must stay in the same order as they are in the beginning).</p>
<p>You want to find out, what is the maximum profit you can get, if you sell the wines in optimal order?"</p>
</blockquote>
<p>So, for example, if the prices of the wines are (in the order as they are placed on the shelf, from left to right): p1=1, p2=4, p3=2, p4=3. The optimal solution would be to sell the wines in the order&nbsp;<strong>p1, p4, p3, p2</strong>&nbsp;for a total profit 1 * 1 + 3 * 2 + 2 * 3 + 4 * 4 = 29.</p>
<p><strong>Wrong solution!</strong></p>
<p>After playing with the problem for a while, you'll probably get the feeling, that in the optimal solution you want to sell the expensive wines as late as possible. You can probably come up with the following greedy strategy:</p>
<blockquote>
<p>Every year, sell the cheaper of the two (leftmost and rightmost) available wines.</p>
</blockquote>
<p>Although the strategy doesn't mention what to do when the two wines cost the same, this strategy feels right. But unfortunately, it isn't, as the following example demonstrates.</p>
<p>If the prices of the wines are: p1=2, p2=3, p3=5, p4=1, p5=4. The greedy strategy would sell them in the order p1, p2, p5, p4, p3 for a total profit 2 * 1 + 3 * 2 + 4 * 3 + 1 * 4 + 5 * 5 = 49.</p>
<p>But, we can do better if we sell the wines in the order&nbsp;<strong>p1, p5, p4, p2, p3</strong>&nbsp;for a total profit 2 * 1 + 4 * 2 + 1 * 3 + 3 * 4 + 5 * 5 = 50.</p>
<p>This counter-example should convince you, that the problem is not so easy as it can look on a first sight and it can be solved using DP.</p>
<p><strong>How? Write a backtrack.</strong></p>
<p>When coming up with the memoization solution for a problem, start with a backtrack solution that finds the correct answer. Backtrack solution enumerates all the valid answers for the problem and chooses the best one.</p>
<p>Here are some restrictions on the backtrack solution:</p>
<ul>
<li>It should be a function, calculating the answer using recursion.</li>
<li>It should return the answer with return statement, i.e., not store it somewhere.</li>
<li>All the non-local variables that the function uses should be used as read-only, i.e. the function can modify only local variables and its arguments.</li>
</ul>
<p><img src="https://he-s3.s3.amazonaws.com/media/uploads/f81150c.png" alt="enter image description here" /></p>
<p>This solution simply tries all the possible valid orders of selling the wines. If there are&nbsp;<strong>N</strong>&nbsp;wines in the beginning, it will try&nbsp;<strong>2<sup>N</sup></strong>&nbsp;possibilities (each year we have 2 choices). So even though now we get the correct answer, the time complexity of the algorithm grows exponentially.</p>
<p>The correctly written backtrack function should always represent an answer to a well-stated question. In our case profit function represents an answer to a question: "<em>What is the best profit we can get from selling the wines with prices stored in the array p, when the current year is year and the interval of unsold wines spans through [be, en], inclusive?</em>"</p>
<p>You should always try to create such a question for your backtrack function to see if you got it right and understand exactly what it does.</p>
<p>We should try to minimize the state space of function arguments. In this step think about, which of the arguments you pass to the function are redundant. Either we can construct them from the other arguments or we don't need them at all. If there are any such arguments, don't pass them to the function. Just calculate them inside the function.</p>
<p>In the above function profit, the argument year is redundant. It is equivalent to the number of wines we have already sold plus one, which is equivalent to the total number of wines from the beginning minus the number of wines we have not sold plus one. If we create a read-only&nbsp;<strong>global variable N,</strong>&nbsp;representing the total number of wines in the beginning, we can rewrite our function as follows:</p>
<pre class="prettyprint prettyprinted"><code> <span class="kwd">int</span><span class="pln"> N</span><span class="pun">;</span> <span class="com">// read-only number of wines in the beginning</span>
    <span class="kwd">int</span><span class="pln"> p</span><span class="pun">[</span><span class="pln">N</span><span class="pun">];</span> <span class="com">// read-only array of wine prices</span>

        <span class="kwd">int</span><span class="pln"> profit</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> be</span><span class="pun">,</span> <span class="kwd">int</span><span class="pln"> en</span><span class="pun">)</span> <span class="pun">{</span>
          <span class="kwd">if</span> <span class="pun">(</span><span class="pln">be </span><span class="pun">&gt;</span><span class="pln"> en</span><span class="pun">)</span>
            <span class="kwd">return</span> <span class="lit">0</span><span class="pun">;</span>
          <span class="com">// (en-be+1) is the number of unsold wines</span>
          <span class="kwd">int</span><span class="pln"> year </span><span class="pun">=</span><span class="pln"> N </span><span class="pun">-</span> <span class="pun">(</span><span class="pln">en</span><span class="pun">-</span><span class="pln">be</span><span class="pun">+</span><span class="lit">1</span><span class="pun">)</span> <span class="pun">+</span> <span class="lit">1</span><span class="pun">;</span> <span class="com">// as in the description above</span>
           <span class="kwd">return</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">
            profit</span><span class="pun">(</span><span class="pln">be</span><span class="pun">+</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> en</span><span class="pun">)</span> <span class="pun">+</span><span class="pln"> year </span><span class="pun">*</span><span class="pln"> p</span><span class="pun">[</span><span class="pln">be</span><span class="pun">],</span><span class="pln">
            profit</span><span class="pun">(</span><span class="pln">be</span><span class="pun">,</span><span class="pln"> en</span><span class="pun">-</span><span class="lit">1</span><span class="pun">)</span> <span class="pun">+</span><span class="pln"> year </span><span class="pun">*</span><span class="pln"> p</span><span class="pun">[</span><span class="pln">en</span><span class="pun">]);</span>
        <span class="pun">}</span></code></pre>
<p>We are now 99% done. To transform the backtrack function with time complexity O(2<sup>N</sup>) into the memoization solution with time complexity O(N<sup>2</sup>), we will use a little trick which doesn't require almost any thinking. As noted above, there are only O(N<sup>2</sup>) different arguments our function can be called with. In other words, there are only O(N<sup>2</sup>) different things we can actually compute.</p>
<p>So where does O(2<sup>N</sup>) time complexity comes from and what does it compute? The answer is - the exponential time complexity comes from the repeated recursion and because of that, it computes the same values again and again. If you run the above code for an arbitrary array of N=20 wines and calculate how many times was the function called for arguments be=10 and en=10 you will get a number 92378.</p>
<p>That's a huge waste of time to compute the same answer that many times. What we can do to improve this is to memoize the values once we have computed them and every time the function asks for an already memoized value, we don't need to run the whole recursion again.</p>
<pre class="prettyprint prettyprinted"><code><span class="kwd">int</span><span class="pln"> N</span><span class="pun">;</span> <span class="com">// read-only number of wines in the beginning</span>
    <span class="kwd">int</span><span class="pln"> p</span><span class="pun">[</span><span class="pln">N</span><span class="pun">];</span> <span class="com">// read-only array of wine prices</span>
    <span class="kwd">int</span><span class="pln"> cache</span><span class="pun">[</span><span class="pln">N</span><span class="pun">][</span><span class="pln">N</span><span class="pun">];</span> <span class="com">// all values initialized to -1 (or anything you choose)</span>

        <span class="kwd">int</span><span class="pln"> profit</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> be</span><span class="pun">,</span> <span class="kwd">int</span><span class="pln"> en</span><span class="pun">)</span> <span class="pun">{</span>
          <span class="kwd">if</span> <span class="pun">(</span><span class="pln">be </span><span class="pun">&gt;</span><span class="pln"> en</span><span class="pun">)</span>
            <span class="kwd">return</span> <span class="lit">0</span><span class="pun">;</span>
         <span class="com">// these two lines save the day</span>
          <span class="kwd">if</span> <span class="pun">(</span><span class="pln">cache</span><span class="pun">[</span><span class="pln">be</span><span class="pun">][</span><span class="pln">en</span><span class="pun">]</span> <span class="pun">!=</span> <span class="pun">-</span><span class="lit">1</span><span class="pun">)</span>
            <span class="kwd">return</span><span class="pln"> cache</span><span class="pun">[</span><span class="pln">be</span><span class="pun">][</span><span class="pln">en</span><span class="pun">];</span>
          <span class="kwd">int</span><span class="pln"> year </span><span class="pun">=</span><span class="pln"> N </span><span class="pun">-</span> <span class="pun">(</span><span class="pln">en</span><span class="pun">-</span><span class="pln">be</span><span class="pun">+</span><span class="lit">1</span><span class="pun">)</span> <span class="pun">+</span> <span class="lit">1</span><span class="pun">;</span>
          <span class="com">// when calculating the new answer, don't forget to cache it</span>
          <span class="kwd">return</span><span class="pln"> cache</span><span class="pun">[</span><span class="pln">be</span><span class="pun">][</span><span class="pln">en</span><span class="pun">]</span> <span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">
            profit</span><span class="pun">(</span><span class="pln">be</span><span class="pun">+</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> en</span><span class="pun">)</span> <span class="pun">+</span><span class="pln"> year </span><span class="pun">*</span><span class="pln"> p</span><span class="pun">[</span><span class="pln">be</span><span class="pun">],</span><span class="pln">
            profit</span><span class="pun">(</span><span class="pln">be</span><span class="pun">,</span><span class="pln"> en</span><span class="pun">-</span><span class="lit">1</span><span class="pun">)</span> <span class="pun">+</span><span class="pln"> year </span><span class="pun">*</span><span class="pln"> p</span><span class="pun">[</span><span class="pln">en</span><span class="pun">]);</span>
        <span class="pun">}</span></code></pre>
<p>To sum it up, if you identify that a problem can be solved using DP, try to create a backtrack function that calculates the correct answer. Try to avoid the redundant arguments, minimize the range of possible values of function arguments and also try to optimize the time complexity of one function call (remember, you can treat recursive calls as they would run in O(1) time). Finally, you can memoize the values and don't calculate the same things twice.</p>
<h1><span style="text-decoration: underline;"><span style="background-color: #ffff00;"><strong>VI. NP-Completeness</strong></span></span></h1>
<p>So far we've seen a lot of good news: such-and-such a problem can be solved quickly (in close to linear time, or at least a time that is some small polynomial function of the input size).</p>
<p>NP-completeness is a form of bad news: evidence that many important problems can't be solved quickly.</p>
<h2>Why should we care?</h2>
<p>These NP-complete problems really come up all the time. Knowing they're hard lets you stop beating your head against a wall trying to solve them, and do something better:</p>
<ul>
<li>Use a heuristic. If you can't quickly solve the problem with a good worst case time, maybe you can come up with a method for solving a reasonable fraction of the common cases.</li>
<li>Solve the problem approximately instead of exactly. A lot of the time it is possible to come up with a provably fast algorithm, that doesn't solve the problem exactly but comes up with a solution you can prove is close to right.</li>
<li>Use an exponential time solution anyway. If you really have to solve the problem exactly, you can settle down to writing an exponential time algorithm and stop worrying about finding a better solution.</li>
<li>Choose a better abstraction. The NP-complete abstract problem you're trying to solve presumably comes from ignoring some of the seemingly unimportant details of a more complicated real world problem. Perhaps some of those details shouldn't have been ignored, and make the difference between what you can and can't solve.</li>
</ul>
<h2>Classification of problems</h2>
<p>The subject of&nbsp;<em>computational complexity theory</em>&nbsp;is dedicated to classifying problems by how hard they are. There are many different classifications; some of the most common and useful are the following. (One technical point: these are all really defined in terms of yes-or-no problems -- does a certain structure exist rather than how do I find the structure.)</p>
<ul>
<li><strong>P</strong>. Problems that can be solved in polynomial time. ("P" stands for polynomial.) These problems have formed the main material of this course.</li>
<li><strong>NP</strong>. This stands for "nondeterministic polynomial time" where nondeterministic is just a fancy way of talking about guessing a solution. A problem is in NP if you can quickly (in polynomial time) test whether a solution is correct (without worrying about how hard it might be to find the solution). Problems in NP are still relatively easy: if only we could guess the right solution, we could then quickly test it.</li>
</ul>
<p><em>NP does not stand for "non-polynomial"</em>. There are many complexity classes that are much harder than NP.</p>
<ul>
<li><strong>PSPACE</strong>. Problems that can be solved using a reasonable amount of memory (again defined formally as a polynomial in the input size) without regard to how much time the solution takes.</li>
<li><strong>EXPTIME</strong>. Problems that can be solved in exponential time. This class contains most problems you are likely to run into, including everything in the previous three classes. It may be surprising that this class is not all-inclusive: there are problems for which the best algorithms take even more than exponential time.</li>
<li><strong>Undecidable</strong>. For some problems, we can prove that there is no algorithm that always solves them, no matter how much time or space is allowed. One very uninformative proof of this is based on the fact that there are as many problems as there real numbers, and only as many programs as there are integers, so there are not enough programs to solve all the problems. But we can also define explicit and useful problems which can't be solved.</li>
</ul>
<p>Although defined theoretically, many of these classes have practical implications. For instance P is a very good approximation to the class of problems which can be solved quickly in practice -- usually if this is true, we can prove a polynomial worst case time bound, and conversely the polynomial time bounds we can prove are usually small enough that the corresponding algorithms really are practical. NP-completeness theory is concerned with the distinction between the first two classes, P and NP.</p>
<h2>Examples of problems in different classes</h2>
<p><a name="x1"></a><span style="color: #ff0000;"><strong>Example 1: Long simple paths</strong>.</span></p>
<p>A&nbsp;<em>simple path</em>&nbsp;in a graph is just one without any repeated edges or vertices. To describe the problem of finding long paths in terms of complexity theory, we need to formalize it as a yes-or-no question: given a graph G, vertices s and t, and a number k, does there exist a simple path from s to t with at least k edges? A solution to this problem would then consist of such a path.</p>
<p>Why is this in NP? If you're given a path, you can quickly look at it and add up the length, double-checking that it really is a path with length at least k. This can all be done in linear time, so certainly it can be done in polynomial time.</p>
<p>However we don't know whether this problem is in P; I haven't told you a good way for finding such a path (with time polynomial in m,n, and K). And in fact this problem is NP-complete, so we believe that no such algorithm exists.</p>
<p>There are algorithms that solve the problem; for instance, list all 2^m subsets of edges and check whether any of them solves the problem. But as far as we know there is no algorithm that runs in polynomial time.</p>
<p><span style="color: #ff0000;"><a name="x2"></a><strong>Example 2: Cryptography</strong>.</span></p>
<p>Suppose we have an encryption function e.g.</p>
<pre>    code=RSA(key,text)
</pre>
<p>The "RSA" encryption works by performing some simple integer arithmetic on the code and the key, which consists of a pair (p,q) of large prime numbers. One can perform the encryption only knowing the product pq; but to decrypt the code you instead need to know a different product, (p-1)(q-1).</p>
<p>A standard assumption in cryptography is the "known plaintext attack": we have the code for some message, and we know (or can guess) the text of that message. We want to use that information to discover the key, so we can decrypt other messages sent using the same key.</p>
<p>Formalized as an NP problem, we simply want to find a key for which code=RSA(key,text). If you're given a key, you can test it by doing the encryption yourself, so this is in NP.</p>
<p>The hard question is, how do you find the key? For the code to be strong we hope it isn't possible to do much better than a brute force search.</p>
<p>Another common use of RSA involves "public key cryptography": a user of the system publishes the product pq, but doesn't publish p, q, or (p-1)(q-1). That way anyone can send a message to that user by using the RSA encryption, but only the user can decrypt it. Breaking this scheme can also be thought of as a different NP problem: given a composite number pq, find a factorization into smaller numbers.</p>
<p>One can test a factorization quickly (just multiply the factors back together again), so the problem is in NP. Finding a factorization seems to be difficult, and we think it may not be in P. However there is some strong evidence that it is not NP-complete either; it seems to be one of the (very rare) examples of problems between P and NP-complete in difficulty.</p>
<p><span style="color: #ff0000;"><a name="x3"></a><strong>Example 3: Chess</strong>.</span></p>
<p>We've seen in the news recently a match between the world chess champion, Gary Kasparov, and a very fast chess computer, Deep Blue. The computer lost the match, but won one game and tied others.</p>
<p>What is involved in chess programming? Essentially the sequences of possible moves form a tree: The first player has a choice of 20 different moves (most of which are not very good), after each of which the second player has a choice of many responses, and so on. Chess playing programs work by traversing this tree finding what the possible consequences would be of each different move.</p>
<p>The tree of moves is not very deep -- a typical chess game might last 40 moves, and it is rare for one to reach 200 moves. Since each move involves a step by each player, there are at most 400 positions involved in most games. If we traversed the tree of chess positions only to that depth, we would only need enough memory to store the 400 positions on a single path at a time. This much memory is easily available on the smallest computers you are likely to use.</p>
<p>So perfect chess playing is a problem in PSPACE. (Actually one must be more careful in definitions. There is only a finite number of positions in chess, so in principle you could write down the solution in constant time. But that constant would be very large. Generalized versions of chess on larger boards are in PSPACE.)</p>
<p>The reason this deep game-tree search method can't be used in practice is that the tree of moves is very bushy, so that even though it is not deep it has an enormous number of vertices. We won't run out of space if we try to traverse it, but we will run out of time before we get even a small fraction of the way through. Some pruning methods, notably "alpha-beta search" can help reduce the portion of the tree that needs to be examined, but not enough to solve this difficulty. For this reason, actual chess programs instead only search a much smaller depth (such as up to 7 moves), at which point they don't have enough information to evaluate the true consequences of the moves and are forced to guess by using heuristic "evaluation functions" that measure simple quantities such as the total number of pieces left.</p>
<p><a name="x4"></a><span style="color: #ff0000;"><strong>Example 4: Knots</strong>.</span></p>
<p>If I give you a three-dimensional polygon (e.g. as a sequence of vertex coordinate triples), is there some way of twisting and bending the polygon around until it becomes flat? Or is it knotted?</p>
<p>There is an algorithm for solving this problem, which is very complicated and has not really been adequately analyzed. However it runs in at least exponential time.</p>
<p>One way of proving that certain polygons are not knots is to find a collection of triangles forming a surface with the polygon as its boundary. However this is not always possible (without adding exponentially many new vertices) and even when possible&nbsp;<a href="http://www.ics.uci.edu/~eppstein/pubs/p-3poly.html">it's NP-complete to find these triangles</a>.</p>
<p>There are also some heuristics&nbsp;<a href="https://www.ics.uci.edu/~eppstein/161/hyperbolic">based on finding a non-Euclidean geometry for the space outside of a knot</a>&nbsp;that work very well for many knots, but are not known to work for all knots. So this is one of the rare examples of a problem that can often be solved efficiently in practice even though it is theoretically not known to be in P.</p>
<p>Certain related problems in higher dimensions (is this four-dimensional surface equivalent to a four-dimensional sphere) are provably undecidable.</p>
<p><a name="x5"></a><span style="color: #ff0000;"><strong>Example 5: Halting problem</strong>.</span></p>
<p>Suppose you're working on a lab for a programming class, have written your program, and start to run it. After five minutes, it is still going. Does this mean it's in an infinite loop, or is it just slow?</p>
<p>It would be convenient if your compiler could tell you that your program has an infinite loop. However this is an undecidable problem: there is no program that will always correctly detect infinite loops.</p>
<p>Some people have used this idea as evidence that people are inherently smarter than computers, since it shows that there are problems computers can't solve. However it's not clear to me that people can solve them either. Here's an example:</p>
<pre>    main()
    {
    int x = 3;
    for (;;) {
        for (int a = 1; a &lt;= x; a++)
        for (int b = 1; b &lt;= x; b++)
            for (int c = 1; c &lt;= x; c++)
            for (int i = 3; i &lt;= x; i++)
                if(pow(a,i) + pow(b,i) == pow(c,i))
                exit;
        x++;
    }
    }
</pre>
<p>This program searches for solutions to Fermat's last theorem. Does it halt? (You can assume I'm using a multiple-precision integer package instead of built in integers, so don't worry about arithmetic overflow complications.) To be able to answer this, you have to understand the recent proof of Fermat's last theorem. There are many similar problems for which no proof is known, so we are clueless whether the corresponding programs halt.</p>
<h2>Problems of complexity theory</h2>
<p>The most famous open problem in theoretical science is whether P = NP. In other words, if it's always easy to check a solution, should it also be easy to find the solution?</p>
<p>We have no reason to believe it should be true, so the expectation among most theoreticians is that it's false. But we also don't have a proof...</p>
<p>So we have this nice construction of complexity classes P and NP but we can't even say that there's one problem in NP and not in P. So what good is the theory if it can't tell us how hard any particular problem is to solve?</p>
<h2>NP-completeness</h2>
<p>The theory of NP-completeness is a solution to the practical problem of applying complexity theory to individual problems. NP-complete problems are defined in a precise sense as the hardest problems in P. Even though we don't know whether there is any problem in NP that is not in P, we can point to an NP-complete problem and say that if there are any hard problems in NP, that problems is one of the hard ones.</p>
<p>(Conversely if everything in NP is easy, those problems are easy. So NP-completeness can be thought of as a way of making the big P=NP question equivalent to smaller questions about the hardness of individual problems.)</p>
<p>So if we believe that P and NP are unequal, and we prove that some problem is NP-complete, we should believe that it doesn't have a fast algorithm.</p>
<p>For unknown reasons, most problems we've looked at in NP turn out either to be in P or NP-complete. So the theory of NP-completeness turns out to be a good way of showing that a problem is likely to be hard, because it applies to a lot of problems. But there are problems that are in NP, not known to be in P, and not likely to be NP-complete; for instance the code-breaking example I gave earlier.</p>
<h2>Reduction</h2>
<p>Formally, NP-completeness is defined in terms of "reduction" which is just a complicated way of saying one problem is easier than another.</p>
<p>We say that A is easier than B, and write A &lt; B, if we can write down an algorithm for solving A that uses a small number of calls to a subroutine for B (with everything outside the subroutine calls being fast, polynomial time). There are several minor variations of this definition depending on the detailed meaning of "small" -- it may be a polynomial number of calls, a fixed constant number, or just one call.</p>
<p>Then if A &lt; B, and B is in P, so is A: we can write down a polynomial algorithm for A by expanding the subroutine calls to use the fast algorithm for B.</p>
<p>So "easier" in this context means that if one problem can be solved in polynomial time, so can the other. It is possible for the algorithms for A to be slower than those for B, even though A &lt; B.</p>
<p>As an example, consider the Hamiltonian cycle problem. Does a given graph have a cycle visiting each vertex exactly once? Here's a solution, using longest path as a subroutine:</p>
<pre>    for each edge (u,v) of G
    if there is a simple path of length n-1 from u to v
        return yes      // path + edge form a cycle
    return no
</pre>
<p>This algorithm makes m calls to a longest path subroutine, and does O(m) work outside those subroutine calls, so it shows that Hamiltonian cycle &lt; longest path. (It doesn't show that Hamiltonian cycle is in P, because we don't know how to solve the longest path subproblems quickly.)</p>
<p>As a second example, consider a polynomial time problem such as the minimum spanning tree. Then for every other problem B, B &lt; minimum spanning tree, since there is a fast algorithm for minimum spanning trees using a subroutine for B. (We don't actually have to call the subroutine, or we can call it and ignore its results.)<a name="cook"></a></p>
<h2>Cook's Theorem</h2>
<p>We are now ready to formally define NP-completeness. We say that a problem A in NP is NP-complete when, for every other problem B in NP, B &lt; A.</p>
<p>This seems like a very strong definition. After all, the notion of reduction we've defined above seems to imply that if B &lt; A, then the two problems are very closely related; for instance Hamiltonian cycle and longest path are both about finding very similar structures in graphs. Why should there be a problem that closely related to all the different problems in NP?</p>
<p>Theorem: an NP-complete problem exists.</p>
<p>We prove this by example. One NP-complete problem can be found by modifying the halting problem (which without modification is undecidable).</p>
<blockquote><strong>Bounded halting</strong>. This problem takes as input a program X and a number K. The problem is to find data which, when given as input to X, causes it to stop in at most K steps.</blockquote>
<p>To be precise, this needs some more careful definition: what language is X written in? What constitutes a single step? Also for technical reasons K should be specified in&nbsp;<em>unary</em>&nbsp;notation, so that the length of that part of the input is K itself rather than O(log K).</p>
<p>For reasonable ways of filling in the details, this is in NP: to test if data is a correct solution, just simulate the program for K steps. This takes time polynomial in K and in the length of program. (Here's one point at which we need to be careful: the program can not perform unreasonable operations such as arithmetic on very large integers, because then we wouldn't be able to simulate it quickly enough.)</p>
<p>To finish the proof that this is NP-complete, we need to show that it's harder than anything else in NP. Suppose we have a problem A in NP. This means that we can write a program PA that tests solutions to A, and halts within polynomial time p(n) with a yes or no answer depending on whether the given solution is really a solution to the given problem. We can then easily form a modified program PA' to enter an infinite loop whenever it would halt with a no answer. If we could solve bounded halting, we could solve A by passing PA' and p(n) as arguments to a subroutine for bounded halting. So A &lt; bounded halting. But this argument works for every problem in NP, so bounded halting is NP-complete.</p>
<h2>How to prove NP-completeness in practice</h2>
<p>The proof above of NP-completeness for bounded halting is great for the theory of NP-completeness, but doesn't help us understand other more abstract problems such as the Hamiltonian cycle problem.</p>
<p>Most proofs of NP-completeness don't look like the one above; it would be too difficult to prove anything else that way. Instead, they are based on the observation that if A &lt; B and B &lt; C, then A &lt; C. (Recall that these relations are defined in terms of the existence of an algorithm that calls subroutines. Given an algorithm that solves A with a subroutine for B, and an algorithm that solves B with a subroutine for C, we can just use the second algorithm to expand the subroutine calls of the first algorithm, and get an algorithm that solves A with a subroutine for C.)</p>
<p>As a consequence of this observation, if A is NP-complete, B is in NP, and A &lt; B, B is NP-complete. In practice that's how we prove NP-completeness: We start with one specific problem that we prove NP-complete, and we then prove that it's easier than lots of others which must therefore also be NP-complete.</p>
<p>So e.g. since Hamiltonian cycle is known to be NP-complete, and Hamiltonian cycle &lt; longest path, we can deduce that longest path is also NP-complete.</p>
<p>Starting from the bounded halting problem we can show that it's reducible to a problem of simulating circuits (we know that computers can be built out of circuits, so any problem involving simulating computers can be translated to one about simulating circuits). So various circuit simulation problems are NP-complete, in particular Satisfiability, which asks whether there is an input to a Boolean circuit that causes its output to be one.</p>
<p>Circuits look a lot like graphs, so from there it's another easy step to proving that many graph problems are NP-complete. Most of these proofs rely on constructing&nbsp;<em>gadgets</em>, small subgraphs that act (in the context of the graph problem under consideration) like Boolean gates and other components of circuits.</p>
<p>There are many problems already known to be NP-complete, and listed in the bible of the subject:</p>
<blockquote>Computers and Intractibility:<br />A guide to the theory of NP-completeness<br />Michael R. Garey and David S. Johnson<br />W. H. Freeman, 1979.</blockquote>
<p>If you suspect a problem you're looking at is NP-complete, the first step is to look for it in Garey and Johnson. The second step is to find as similar a problem as you can in Garey and Johnson, and prove a reduction showing that similar problem to be easier than the one you want to solve. If neither of these works, you could always go back to the methods described in the rest of this class, and try to find an efficient algorithm...</p>
<hr /><center></center><center></center></div>
</div>
</div>
</div>
</div>
</div>
</div>
